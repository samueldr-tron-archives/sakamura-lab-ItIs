
		＝ ItIs Phase3 ユーザズマニュアル ＝

	     (Release 1.3β対応，最終更新: 30-Jan-1998)


※ このユーザズマニュアルは，μITRON3.0標準ハンドブックの内容を前提に
書かれています．μITRON3.0標準ハンドブックを手元においてお読み下さい．

坂村 健 監修, 「μITRON3.0標準ハンドブック」, パーソナルメディア,
1993, ISBN4-89362-106-8.

    * TRON は The Real-time Operating system Nucleus の略称です．
    * ITRON は Industrial TRON の略称です．

------------------------------------------------------------------------ 
	    ItIs - ITRON Implementation by Sakamura Lab

Copyright (C) 1989-1997 by Sakamura Lab, the University of Tokyo, JAPAN

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the name of the University nor the names of the laboratory
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE UNIVERSITY OR THE LABORATORY BE LIABLE FOR ANY
DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
------------------------------------------------------------------------


１．ItIs Phase3 の概要

ItIs Phase3 (以下単に ItIs と書く) は，東京大学坂村研究室で研究・教育
用に開発された，μITRON3.0仕様に準拠したリアルタイムカーネルである．現
バージョンで，レベルE までのすべての機能 (接続機能を除く) を実現してお
り，いくつかの独自の拡張機能も持っている．


1.1. ターゲットシステム，開発環境

ターゲットCPU として，現時点では，TRON仕様チップ (Gmicro/200 と 
Gmicro/300 で動作確認) のみをサポートしている．CPU依存の部分を分離する
など，他の CPU への移植についても考慮しているが，どの程度の手間がかか
るかは移植先の CPU のアーキテクチャに大きく依存する．

開発環境としては，TRON仕様チップ用 GNU開発環境の新版 (GCC 2.X) を用い
ている．GCC 2.X の拡張機能 (long long 型，インラインアセンブラ機能など) 
やパラメータ渡しのコンベンションに依存している部分がある．

カーネル自身は，必要なライブラリをすべて含んでいるが，一部のシステムタ
スクは標準Cライブラリを必要とする．カーネルが必要とする標準のヘッダファ
イルは，stdarg.h (可変数引数を処理するため) と limits.h (INT_MAX を参
照するため) のみである．

ターゲットシステムとして，Gmicroグループ各社製の Gmicro SBCシステムの 
CPUボード HS32/200SBC (CPU: Gmicro/200) および HS32/300SBC (CPU:
Gmicro/300)，アバールデータ社製の TVME-150 CPUボード (CPU: Gmicro/200)，
パーソナルメディア社製の MCUBE (SIGBTRON基本ボード, CPU: Gmicro/300) 
をサポートしている．他のターゲットシステムへの移植の際は，ターゲット依
存モジュールの書き直しが必要になる．


1.2. シミュレーション環境

ItIs のシミュレーション環境として，BSD UNIX上で動作する設定を用意して
いる．このシミュレーション環境は，BSD UNIX の 1つのプロセスの中で複数
のタスクを切り替えて動作させるもので，BSD UNIX上のスレッドライブラリと
して使うこともできる．ただし，サポートしている機能には限定がある．

現時点では，ターゲットシステムとして SunOS 4.X (Sparc) と FreeBSD
(x86) のみをサポートしているが，他の BSD UNIX への移植も可能である．
BSD UNIX に依存した機能を利用しているため，他の系列の UNIX への移植は
手間がかかるものと思われる．

BSD UNIX上でのシミュレーション環境についての詳細は，「BSD UNIX 上での
動作環境」を参照のこと．


1.3. サポートしない機能

実装依存機能である例外ハンドラの機能はサポートしていない．

現バージョンのカーネルは，FPU をサポートしていない (タスクディスパッチ
時などに，FPU レジスタを保存しない)．そのため，複数のタスクが FPU を使
用した場合の動作は保証されない．また，割込みハンドラなどのハンドラが 
FPU を使用する場合には，ユーザが FPU レジスタの保存・復帰を行う必要が
ある．


1.4. サポートしないシステムコール

以下のレベルC システムコールはサポートしない．

    dis_int	割込み禁止
    ena_int	割込み許可
    def_exc	例外ハンドラ定義
	
また，以下のシステムコールは，他の方法で代用できるためサポートしない．

    ret_int	割込みハンドラからの復帰
    ret_wup	割込みハンドラ復帰とタスク起床
    ret_tmr	タイマハンドラからの復帰


1.5. μITRON3.0仕様に従っていない部分

ItIs は，以下の点でμITRON3.0仕様に従っていない．

・μITRON3.0仕様では，機能コードを表すデータ型 FN のサイズは最大 2バイ
トとしているが，ItIs では 4バイトで扱っている．これは，TRON仕様チップ
の場合，あえてハーフワードで扱うメリットがほとんどないためである．

・μITRON3.0仕様では，時間指定のためのデータ型 SYSTIME，CYCTIME，
ALMTIME のサイズは 48ビットを推奨しているが，ItIs ではこれらを 64ビッ
トで扱っている．これは，GCC の long long 型を用いた方がプログラムの見
通しがよく，移植性の面からも有利であると考えたためである．

・μITRON3.0仕様では，ユーザタスクがシステムオブジェクト (ID番号が負の
オブジェクト) をアクセスすると E_OACVエラーになるが，ItIs ではリングレ
ベル0 で動作しているユーザタスクからもシステムオブジェクトをアクセスす
ることができる．この仕様は，ユーザタスクをリングレベル0 で動作させる機
能が追加されたと考えれば，拡張機能であると考えることもできる．

・μITRON3.0仕様では，タスクの優先度は，タスク起動時にタスク起動時優先
度に設定されるとしているが，ItIs では，タスク生成時およびタスク終了時
に設定される．これは，DORMANT状態のタスクに対して chg_pri を発行し，タ
スク起動直後の優先度を設定可能とするためである．この仕様は，外部仕様的
には，DORMANT状態のタスクに対する chg_pri を可能にしたという拡張機能に
なっている．

・μITRON3.0仕様では，ランデブの応答メッセージの長さが 0 の場合はエラー
とし，rpl_rdv が E_PARエラーを返すとしているが，ItIs では長さが 0 の応
答メッセージも使うことができる．これは，応答メッセージが不要な場合のた
めの仕様で，一種の拡張機能である．逆に，呼出メッセージが不要な状況はほ
とんど考えられないため，呼出メッセージの長さが 0 の場合はエラーとして
いる．

・μITRON3.0仕様では，mplid = (-4) のシステム用メモリプールをユーザタ
スクからも状態参照できることになっているが，ItIs ではリングレベル0 以
外で動作しているタスクから状態参照することはできない．これには，深い意
味はない．


1.6. 拡張機能

ItIs は，μITRON3.0仕様に定義されている以外に，以下の拡張機能をサポー
トしている．拡張機能をサポートするかどうかは，システム構成設定ファイル
中で指定することができる．

(1) ID自動割当機能

μITRON3.0仕様では，オブジェクトを生成するシステムコール，タイマハンド
ラを定義するシステムコールで，オブジェクトの ID ないしはタイマハンドラ
の番号を明示的に指定する必要がある．この仕様は，動作するタスクがあらか
じめわかっているようなケース (ほとんどの組み込みシステムはこれに該当す
る) には適当であるが，より大規模な OS のマイクロカーネルとして用いるな
ど，動作するタスクがわからない場合には使いにくい．

ItIs では，オブジェクトの ID およびタイマハンドラの番号を，自動的に割
り当てる機能をサポートしている．オブジェクトの ID については，自動割当
の対象になるのは，正の ID のみである．この機能をサポートするために追加
されたシステムコールは次の通りである．

    vcre_tsk	タスク生成 (ID自動割当)
    vcre_sem	セマフォ生成 (ID自動割当)
    vcre_flg	イベントフラグ生成 (ID自動割当)
    vcre_mbx	メイルボックス生成 (ID自動割当)
    vcre_mbf	メッセージバッファ生成 (ID自動割当)
    vcre_por	ランデブ用のポート生成 (ID自動割当)
    vcre_mpl	可変長メモリプール生成 (ID自動割当)
    vcre_mpf	固定長メモリプール生成 (ID自動割当)
    vdef_cyc	周期起動ハンドラ定義 (ハンドラ番号自動割当)
    vdef_alm	アラームハンドラ定義 (ハンドラ番号自動割当)

(2) デバッグサポート機能

デバッグサポート機能とは，ItIs上で動作するタスクのデバッグを容易にする
ための機能で，主にデバッガで利用される機能である．現バージョンでは，以
下の 2つのシステムコールをサポートしている．

    vset_reg	タスクのレジスタ内容の設定
    vget_reg	タスクのレジスタ内容の参照

(3) 性能評価用システム時刻参照機能

性能評価用システム時刻参照機能とは，ItIs上で動作するタスクや ItIs 自身
の性能を計測するために，システム時刻をμ秒単位で読み出す機能である．こ
の機能をサポートするために追加されたシステムコールは次の通りである．

    vget_tim	性能評価用システム時刻の参照

(4) 優先度継承セマフォ機能

優先度継承セマフォとは，優先度継承プロトコルを実現するための同期オブジェ
クトである．現バージョンでは，バイナリセマフォのみをサポートしている．
この機能は，ITRON仕様カーネルで優先度継承プロトコルを実現するための機
構の研究の一貫として実装したもので，2通りの仕様を用意している．将来的
には，どちらかの仕様しかサポートしないケースや，どちらでもない第3の仕
様をサポートするケースも考えられる．この機能をサポートするために追加さ
れたシステムコールは次の通りである．

    vcre_pis	優先度継承セマフォ生成
    vvcre_pis	優先度継承セマフォの生成 (ID自動割当)
    vdel_pis	優先度継承セマフォ削除
    vsig_pis	優先度継承セマフォ資源返却
    vwai_pis	優先度継承セマフォ資源獲得
    vpreq_pis	優先度継承セマフォ資源獲得 (ポーリング)
    vtwai_pis	優先度継承セマフォ資源獲得 (タイムアウト有)
    vref_pis	優先度継承セマフォ状態参照

(5) タスク付属メイルボックス機能

タスク付属メイルボックスとは，特定のタスクに付属し，そのタスクのみが受
信可能なメイルボックスである．この機能は，μITRON (ver 2.0) では定義さ
れていたが，μITRON3.0 では TCB を小さくし適応化を容易にするという理由
により，仕様から外されたものである．ItIs のタスク付属メイルボックス機
能は，μITRON (ver 2.0) の仕様を参考にして実装したものである．この機能
をサポートするために追加されたシステムコールは次の通りである．

    vsnd_tmb	タスク付属メイルボックスへ送信
    vrcv_tmb	タスク付属メイルボックスから受信
    vprcv_tmb	タスク付属メイルボックスから受信 (ポーリング)
    vtrcv_tmb	タスク付属メイルボックスから受信 (タイムアウト有)
    vref_tmb	タスク付属メイルボックス状態参照


２．全般

2.1. オブジェクトID

負のオブジェクトID はシステムオブジェクト，正のオブジェクトID はユーザ
オブジェクトを表す．(-4)〜0 のオブジェクトID は予約されており，システ
ムが利用するオブジェクトが割り当てられている場合を除いては，利用できな
い．

システムオブジェクトをアクセスする権利を持つのは，タスク独立部実行中，
準タスク部実行中，システムタスク (タスクID が負のオブジェクト) 実行中
およびリングレベル0 で動作しているユーザタスク実行中である (タスクのリ
ングレベルについては，「cre_tsk」の項を参照)．μITRON3.0仕様の規定との
違いは，正の ID のユーザタスクであっても，リングレベル0 で動いている場
合には，システムタスクと同じアクセス権を持っていることである．システム
オブジェクトをアクセスする権利を持たない環境から，システムオブジェクト
をアクセスするシステムコールを発行した場合，E_OACVエラーとなる．

各オブジェクトの ID の範囲は，システム構成設定ファイル中で指定すること
ができる．オブジェクトの数を 0 にした場合 (ID の最大値を最小値より 1 
小さい値にした場合)，そのオブジェクトをサポートしないカーネルを作るこ
とができる．ただし現状では，カーネルやシステムタスクが使用しているオブ
ジェクトの数を 0 にした場合の動作は保証しない．

オブジェクト以外で番号を持つ資源として，周期起動ハンドラ，アラームハン
ドラ，拡張SVCハンドラがある．これらの資源の番号は，1 から始まり，最大
値をシステム構成設定ファイル中で指定することができる．最大値を 0 にし
た場合，その資源をサポートしないカーネルを作ることができる．


2.2. 優先度値

優先度値の下限と上限は，システム構成設定ファイル中で指定することができ
る．(-4)〜0 の優先度は予約されており，利用できない．

優先度値のレベルを多くするとレディキューのサイズが大きくなるので注意が
必要である (256レベルで 2KB強になる)．


2.3. 時間パラメータ

ItIs では，時間を表すパラメータ (SYSTIME，CYCTIME，ALMTIME，DLYTIME，
TMO 型のもの) の基準時間を，すべて 1ミリ秒としている．

ハードウェアタイマによる周期割込みの間隔についても，1ミリ秒を標準とす
るが，ターゲットシステム依存のタイマモジュールのみの修正で変更できる．


2.4. エラーチェック

ItIs ではいくつかの種類のエラーについて，チェックするかどうかを，シス
テム構成設定ファイル中で指定することができる．現バージョンでは，指定で
きるエラーの種類は，以下の 9つである．これ以外のエラーは，必ずチェック
する．

    CHK_NOSPT:	未サポート機能 (E_NOSPT) をチェックする．

    CHK_RSATR:	予約属性エラー (E_RSATR) をチェックする．

    CHK_PAR:	パラメータエラー (E_PAR) をチェックする．

    CHK_ID:	不正ID番号 (E_ID) をチェックする．

    CHK_OACV:	オブジェクトアクセス権違反 (E_OACV) をチェックする．

    CHK_CTX:	通常のコンテキストエラー (E_CTX) をチェックする．

    CHK_CTX1:	コンテキストエラー (E_CTX) の内，エラーの場合にもシス
		テムコールを発行したコンテキストに戻らないものをチェッ
		クする．具体的には，ext_tsk および exd_tsk がディスパッ
		チ禁止中に呼ばれた場合のコンテキストエラーをチェックす
		る．

    CHK_CTX2:	致命的なコンテキストエラー (E_CTX) が起こった時に，シ
		ステムを安全にダウンさせる．具体的には，タスク独立部か
		ら ext_tsk および exd_tsk が呼ばれた場合に，システムを
		ダウンさせる．

    CHK_SELF:	自タスクを対象として発行できないシステムコールを，自タ
		スクに対して発行した時に発生するエラー (E_OBJ) をチェッ
		クする．

チェックを省略したエラーが起こる条件でシステムコールを呼びだした場合の
動作は保証されない．

ItIs の現バージョンでは，カーネルが以下のエラーが報告することはない．

    E_SYS	システムエラー
    E_INOSPT	ITRON/FILE での未サポート機能
    E_MACV	メモリアクセス不能，メモリアクセス権違反
    EN_????	接続機能に関するエラー

また，パラメータとしてポインタを渡すシステムコールに対して，存在しない
メモリ番地をアクセスするようなポインタを渡した場合のエラーは，カーネル
では検出されない．そのような呼び出しをした場合，CPU がバスエラーを起こ
すことになる．


2.5. 準タスク部

準タスク部とは，タスクのコンテキストを持ちながらハンドラを実行している
状態のことをいう．準タスク部実行中は，タスクディスパッチが可能であり，
遅延割込みの原則は準タスク部には適用されない．また，準タスク部の中から，
自タスクを待ち状態にするシステムコールを発行することができる．

現バージョンでは，準タスク部になるのは，拡張SVCハンドラ実行中のみであ
る (ただし，タスク独立部から呼び出された拡張SVCハンドラ実行中は，準タ
スク部ではなく，タスク独立部であると扱われる)．将来的に接続機能がサポー
トされる場合，接続機能をサポートするシステムコールは準タスク部で実現さ
れることになる．そのため，準タスク部で実現されている拡張SVC や接続機能
をサポートするシステムコールに対しては，システムコールの不可分性は適用
されない．

カーネルに準タスク部をサポートさせるかどうかは，システム構成設定ファイ
ル中で指定することができる．ただし，拡張SVCハンドラを使うという設定を
した場合，準タスク部をサポートするかどうかの指定にかかわらず，準タスク
をサポートするカーネルが作られる．


2.6. コンパイル時のオプション

カーネルのコード中には，assertマクロが数多く使われている．assertマクロ
は，NDEBUG を定義することで，オブジェクトコード中から消すことができる．
カーネルのデバッグが終了すれば，-DNDEBUG を指定してコンパイルした方が
効率がよくなる．

カーネルコード中で，以下の TRON仕様チップの L2レベルの命令を使用してい
る．L1レベルの CPU で動作させる場合には，コンパイル時に -DTRON_LEVEL1 
を指定することが必要である．

    qsch/ge/f	キューサーチ命令
    bvsch/1/f	任意長ビットフィールドサーチ命令

ItIs は，TRON仕様チップの遅延割込みの機能を使っているが，他の CPU への
移植性を検証するために，遅延割込みを使わない設定も用意している．コンパ
イル時に，-DTRON_NO_DI を指定することで，この設定が使われる．

ItIs では，カーネルのサイズを最小限にし，他のライブラリに依存しないよ
うにするために，機能を縮小した簡易版の vsprintf関数である itis_vsprintf 
を用意している．デフォルトでは，カーネルと一緒にリンクされるタスクが呼
び出す syslog関数の中でも，itis_vsprintf を使うように設定されている．
タスクが呼び出す syslog関数からは標準Cライブラリ中の vsprintf を使わせ
たい場合には，syslog.c をコンパイルする際に，-Ditis_vsprintf=vsprintf 
というオプションをつければよい．

また，itis_vsprintf が long long 型の表示をサポートする必要がある場合，
vsprintf.c をコンパイルする際に -DUSE_LONGLONG を指定する．


2.7. システムコールインタフェース

ItIs では，タスクからシステムコールを呼び出すインタフェースとして，
TRAPA (ソフトウェア割込み) によるものと，サブルーチンコールによるもの
の両方を利用することができる．ただし，サブルーチンコールによるインタフェー
スを用いることができるのは，リングレベル0 で動いているタスクのみである．
これは，カーネルはリングレベル0 で動作する必要があるが，サブルーチンコー
ルではリングレベルを変えられないためである．また，拡張SVC をサブルーチ
ンコールによるインタフェースで呼び出す方法はサポートしていない．

システムコールインタフェースを決める際には，C言語から呼び出した場合の
効率を重視した．そのため，アセンブラインタフェースについては，
μITRON3.0仕様での推奨や，ITRON2 での標準に従わなくなっている．

(1) TRAPA を使うインタフェース

カーネルの呼び出しには TRAPA #1 を用いる．機能コードは，μITRON3.0仕様
の標準に従っている．

TRAPA を使ったインタフェースの場合，リングレベルが変わる可能性があるた
め，スタック上にパラメータを置くインタフェースは望ましくない．そこで，
コンパイラがパラメータをスタック上に置く場合には，システムコールを呼び
出す前にスタック上のパラメータをレジスタに転送し，呼び出された後にその
逆の作業をする必要がある．

TRON仕様チップ用の GCC 2.X では，パラメータをレジスタを使って渡す方法
を標準としているため，コンパイラのパラメータ渡しのコンベンションがその
まま使える．具体的には，第1パラメータを R0，第2パラメータを R1，…，第
6パラメータを R5 に置く (μITRON3.0仕様の C言語インタフェースでは，最
大 6つのパラメータを用いる)．機能コードはパラメータ渡しに使わないレジ
スタに入れる必要があるため，R6 に入れる．

エラーコード以外のリターンパラメータを返す場合には，リターンパラメータ
を入れる領域へのポインタをパラメータとして渡す (μITRON3.0仕様の C言語
インタフェースと同じ)．エラーコードは，R0 に入れて返される．システムコー
ルの実行によって，R1〜R6 の各レジスタの値は保存されない．

(2) サブルーチンコールを使うインタフェース

システムコール xxx_yyy を呼び出す関数名を，i_xxx_yyy とする．名前の違
いを吸収するヘッダファイルを用意しているので，タスクからは xxx_yyy の
形で呼び出せばよい．

パラメータの渡し方，エラーコードの受け取り方は，コンパイラのコンベンショ
ンに従えばよい．TRON仕様チップ用の GCC 2.X では，第1パラメータを R0，
第2パラメータを R1，...，第6パラメータを R5 に置いてシステムコールを呼
び出す．エラーコードは R0 に返される．システムコールの実行によって，R1〜
R6 の各レジスタの値は保存されない．

サブルーチンコールを使うインタフェースを利用する場合，ItIsアプリケーショ
ン用の標準インクルードファイル (itis_services.h) をインクルードする前
に，LINK_KERNEL を定義しておく．


2.8. タスク，ハンドラの起動インタフェース

(1) タスク起動インタフェース

タスク起動時には，R0 にタスク起動コードが入る．また，ItIs では，R1 に
タスクの拡張情報が渡される．GCC 2.X のパラメータ渡しのコンベンションに
一致しているため，C言語のための高級言語対応ルーチンは必要ない．タスク
を C言語で記述する時は，

	void	task_entry(INT stacd, VP exinf)

の形で書けばよい．拡張情報が必要ない場合は，VP exinf は省略できる．タ
スクを終了する場合は，ext_tsk ないしは exd_tsk を用いる．単に return 
した場合の動作は保証されない．

(2) タイマハンドラ (周期起動ハンドラ，アラームハンドラ)

μITRON3.0仕様では，タイマハンドラに渡されるパラメータはないが，ItIs 
では，R0 にタイマハンドラの拡張情報が渡される．GCC 2.X のパラメータ渡
しのコンベンションに一致しているため，C言語のための高級言語対応ルーチ
ンは必要ない．タイマハンドラを C言語で記述する時は，

	void	timer_handler(VP exinf)

の形で書けばよい．拡張情報が必要ない場合は，VP exinf は省略できる．タ
イマハンドラから戻る際は，単に return すればよい．

(3) 拡張SVCハンドラ

拡張SVCハンドラに対するパラメータ渡しは，コンパイラのコンベンションに
従う．TRAPA を用いたインタフェースの場合は R6 に機能コードを置くため，
最大パラメータ数は 6つとなる．当然ながら，高級言語対応ルーチンは不要に
なる．拡張SVCハンドラを C言語で記述する時は，

	ER	svc_handler(INT par1, INT par2, ..., INT par6)

の形で書けばよい (パラメータは，必要な数だけ書けばよい)．拡張SVCハンド
ラから戻る際は，単に return すればよい．

なお，サブルーチンコールを使ったインタフェースで拡張SVCハンドラを呼ぶ
方法については，特別なサポートはしていないが，拡張SVCハンドラとそれを
呼び出すルーチンが一緒にリンクされるならば，通常の関数呼び出しの方法で
呼び出すことができる (サブルーチンコールを使ってシステムコールを呼び出
せるのは，リングレベル0 で動いているタスクのみであることに留意せよ)．

また，タスク独立部から拡張SVCハンドラを呼ぶことも可能である．タスク独
立部から呼ばれた拡張SVCハンドラ実行中は，準タスク部ではなく，タスク独
立部であると扱われるため，注意が必要である．

(4) 割込みハンドラ

ItIs では，高級言語対応ルーチンを用いた場合 (C言語で記述した関数が破壊
するレジスタを保存するために，高級言語対応ルーチンは不可欠である)，R0 
に EITスタックフレームの先頭番地が渡される．割込みハンドラを C言語で記
述する時は，

	void	interrupt_handler(VP pk_eit)

の形で書けばよい．EITスタックフレームの先頭番地が必要ない場合は，VP
pk_eit は省略できる．REIT命令は高級言語対応ルーチン中に書かれているの
で，割込みハンドラから戻る際は，単に return すればよい．


2.9. タスク独立部から発行できるシステムコール

μITRON3.0仕様では，タスク独立部から発行できるシステムコールはインプリ
メント依存としているが，ItIs の現バージョンでは，仕様書で明示的に発行
できないとされているシステムコールに加えて，以下に挙げるシステムコール
をタスク独立部から呼び出すことはできない．これ以外のシステムコールは，
すべてタスク独立部から呼び出すことができる．

    他タスク強制終了 (ter_tsk)
    ランデブ用ポートの生成・削除・参照 (cre_por, del_por, ref_por, vcre_por)
    タスクのレジスタ内容の設定・参照 (vset_reg, vget_reg)

ter_tsk をタスク独立部から呼び出せるように改造することも可能であるが，
有用性とオーバーヘッドを比べた場合に，それほどメリットはないと考えた．
また将来的には，cre_???，del_???，一部の def_???，一部の ref_??? など
のシステムコールをタスク独立部から呼ぶことを禁止するかもしれない．

μITRON3.0仕様で認められているタスク独立部からシステムコールを呼ぶ場合
に i???_??? の名称を用いるという方法は採用していない．


３．システムコール

以下では，各システムコールの仕様について，μITRON3.0仕様でインプリメン
ト依存となっている部分および ItIs での拡張機能を中心に述べる．


3.1. タスク管理機能

(1) cre_tsk		タスク生成

・タスク属性 (tskatr) の内，コプロセッサに関するものはサポートしていな
い．指定すると E_RSATRエラーになる．

・システムスタックのサイズは，システム全体で固定したデフォルト値を用い
る方法と，cre_tsk でタスク毎に指定する方法がある．前者の方法で，システ
ム全体でのデフォルト値を変更したい場合は，システム構成設定ファイル中の 
def_sys_stack_size で指定する．タスク毎に指定する場合は，タスク属性に 
TA_SSTKSZ を設定し，T_CTSK構造体の sstkszフィールドに指定するサイズを
入れる．この場合，指定したシステムスタックのサイズが小さすぎる場合には，
E_PARエラーとなる．

#define TA_SSTKSZ	0x00010000	/* システムスタックサイズを指定 */

・タスクをどのリングレベルで実行するかは，次の方法で決める．タスクID 
が負の場合には，そのタスクはシステムタスクであると考えてリングレベル0 
で実行する．正の場合には，以下のタスク属性により，どのリングレベルで実
行するかを指定することができる．

#define TA_RNG0		0x00000000	/* リングレベル0 で動作させる */
#define TA_RNG1		0x01000000	/* リングレベル1 で動作させる */
#define TA_RNG2		0x02000000	/* リングレベル2 で動作させる */
#define TA_RNG3		0x03000000	/* リングレベル3 で動作させる */

・タスク属性に TA_HLNG を指定しても，実際には何もしない．

・タスクをリングレベル0 で動かす場合には，ユーザスタックとシステムスタッ
クは区別されない．この場合，両者のサイズを加えたサイズのスタック領域が
確保される．

・ユーザスタックおよびシステムスタックの領域は，cre_tsk 実行時に，シス
テムメモリプールから取られる．取れない場合には，E_NOMEMエラーとなる．

・ユーザスタックのサイズに 0 を指定した場合，カーネルはユーザスタック
エリアを確保しない．ユーザが自分でスタック領域を決めたい場合には，この
方法を使う．

(2) del_tsk		タスク削除

(3) sta_tsk		タスク起動

・ItIs では，タスクの優先度は，タスク起動時ではなく，タスク生成時およ
びタスク終了時に，タスク起動時優先度に設定される．

(4) ext_tsk		自タスク終了

・ext_tsk が検出する E_CTXエラーは，システムログに記録する．タスク独立
部から ext_tsk を呼び出した場合，システムダウンする (CHK_CTX2 を指定し
た場合)．

・優先度継承セマフォ機能を用いている場合には，タスクの終了によって，獲
得している優先度継承セマフォが自動的に解放される場合がある．詳しくは，
「優先度継承セマフォ機能の仕様」を参照のこと．

(5) exd_tsk		自タスクの終了と削除

・exd_tsk が検出する E_CTXエラーは，システムログに記録する．タスク独立
部から exd_tsk を呼び出した場合，システムダウンする (CHK_CTX2 を指定し
た場合)．

・優先度継承セマフォ機能を用いている場合には，タスクの終了によって，獲
得している優先度継承セマフォが自動的に解放される場合がある．詳しくは，
「優先度継承セマフォ機能の仕様」を参照のこと．

(6) ter_tsk		他タスク強制終了

・ItIs では，ter_tsk をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．

・優先度継承セマフォ機能を用いている場合には，タスクの終了によって，獲
得している優先度継承セマフォが自動的に解放される場合がある．また，タス
クの強制終了によって待ち状態が解除されるのに伴って，他のタスクの優先度
が変更される場合がある．詳しくは，「優先度継承セマフォ機能の仕様」を参
照のこと．

(7) dis_dsp		ディスパッチ禁止

・dis_dsp は，IMASK を 14 に設定する．

(8) ena_dsp		ディスパッチ許可

・ena_dsp は，IMASK を 15 に設定する．

(9) chg_pri		タスク優先度変更

・tskpri として TSK_INI を指定して，タスク起動時優先度に戻す機能をサポー
トしている．

・ItIs では，DORMANT状態のタスクに対してこのシステムコールを発行し，タ
スク起動直後の優先度を設定することができる．タスクの優先度は，タスク生
成時およびタスク終了時に，タスク起動時優先度に設定される．そのため，こ
のシステムコールが E_OBJエラーを返すことはない．

・優先度継承セマフォ機能を用いている場合には，指定した以外のタスクの優
先度も変更される場合がある．詳しくは，「優先度継承セマフォ機能の仕様」
を参照のこと．

(10) rot_rdq		タスクのレディキュー回転

・タスク独立部から tskpri = TPRI_RUN を指定して rot_rdq を発行すること
が可能で，その場合，レディキュー中の最高優先度のタスクを含むレディキュー
を回転させる．

・自タスクが属するレディキューを回転させた場合でも，ディスパッチ禁止の
設定や，割込みがかかるタイミング等の要因により，自タスクが同じ優先度の
タスク中の最後に移動するとは限らない．自タスクを同じ優先度のタスク中の
最後に移動させたい場合は，chg_pri を使って自タスクの優先度を現在値に設
定しなおす方法が確実である．

(11) rel_wai		他タスクの待ち状態解除

・優先度継承セマフォ機能を用いている場合には，タスクの待ち状態が解除さ
れるのに伴って，他のタスクの優先度が変更される場合がある．詳しくは，
「優先度継承セマフォ機能の仕様」を参照．

(12) get_tid		自タスクのタスクID参照

(13) ref_tsk		タスク状態参照

・以下のインプリメント依存の情報が参照できる．

	tskwait		待ち要因
	wid		待ちオブジェクトID
	wupcnt		起床要求キューイング数
	suscnt		SUSPEND要求ネスト数

・CPU がコンテキストを持っているタスクを RUN状態であるとする．つまり，
RUN状態のタスクは，タスクディスパッチにより切り替わることになる．その
ため，遅延ディスパッチの原則やディスパッチの禁止によりディスパッチが遅
延されている間は，ディスパッチ前のタスクが RUN状態となる．

例えば，割込みハンドラから RUN状態のタスクに対して sus_tsk を発行した
後に，同じハンドラ内でそのタスクの状態を ref_tsk で参照した場合，発行
した sus_tsk によりタスクが強制待ち状態に移行する場合にも，遅延ディス
パッチの原則により ref_tsk は tskstat に TTS_RUN を返す．

・tskwait が (TTW_CAL|TTW_RDV) になることはない．


3.2. タスク付属同期機能

(1) sus_tsk		他タスクを強制待ち状態へ移行

・SUSPEND要求のネストの機能をサポートしている．ネスト回数の制限値は，
INT型で表現できる最大値である．

(2) rsm_tsk		強制待ち状態のタスクを再開
(3) frsm_tsk		強制待ち状態のタスクを強制再開

・RUN，READY状態のタスクが sus_tsk により SUSPEND状態になった後，
rsm_tsk，frsm_tsk によって実行を再開した場合，レディキューの該当優先度
の最後に入る．

(4) slp_tsk		自タスクを起床待ち状態へ移行

(5) tslp_tsk		自タスクを起床待ち状態へ移行 (タイムアウト有)

・tmout = 0 で呼び出すことにより，slp_tsk に対するポーリングを行うこと
ができる．

(6) wup_tsk		他タスクの起床

・起床要求のキューイング数の制限値は，INT型で表現できる最大値である．

(7) can_wup		タスクの起床要求を無効化


3.3. 同期・通信機能

(1) cre_sem		セマフォ生成

・セマフォ属性として，待ちタスクの優先度順のキューイング (TA_TPRI) を
サポートしている．

・isemcnt と maxcnt を指定する機能をサポートしている．

(2) del_sem		セマフォ削除

(3) sig_sem		セマフォ資源返却

・セマフォの最大値 (maxcnt) をチェックする機能をサポートしている．

(4) wai_sem		セマフォ資源獲得
(5) preq_sem		セマフォ資源獲得 (ポーリング)
(6) twai_sem		セマフォ資源獲得 (タイムアウト有)

(7) ref_sem		セマフォ状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．

(8) cre_flg		イベントフラグ生成

・イベントフラグ属性として，複数タスクの待ちを許すイベントフラグ 
(TA_WMUL) をサポートしている．

(9) del_flg		イベントフラグ削除

(10) set_flg		イベントフラグのセット
(11) clr_flg		イベントフラグのクリア

(12) wai_flg		イベントフラグ待ち
(13) pol_flg		イベントフラグ待ち (ポーリング)
(14) twai_flg		イベントフラグ待ち (タイムアウト有)

(15) ref_flg		イベントフラグ状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．

(16) cre_mbx		メイルボックス生成

・メイルボックス属性として，待ちタスクの優先度順のキューイング 
(TA_TPRI) およびメッセージの優先度順のキューイング (TA_MPRI) をサポー
トしている．

・メイルボックスは線形リストによって管理しているため，リングバッファの
大きさを指定するための bufcnt は使わない．

(17) del_mbx		メイルボックス削除

(18) snd_msg		メイルボックスへ送信

・メイルボックスは線形リストによって管理されているため，メッセージの先
頭に，カーネルが使用するリンクおよびメッセージ優先度を入れるためのヘッ
ダ領域が必要である (TRON仕様チップの場合は，あわせて 8バイト)．

・同じ理由により，E_QOVRエラーは起こらない．

(19) rcv_msg		メイルボックスから受信
(20) prcv_msg		メイルボックスから受信 (ポーリング)
(21) trcv_msg		メイルボックスから受信 (タイムアウト有)

・メイルボックスは線形リストによって管理されているため，メッセージの先
頭に，カーネルが使用するリンクおよびメッセージ優先度を入れるためのヘッ
ダ領域が必要である (TRON仕様チップの場合は，あわせて 8バイト)．

(22) ref_mbx		メイルボックス状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．


3.4. 拡張同期・通信機能

(1) cre_mbf		メッセージバッファ生成

・メッセージバッファ属性として，待ちタスクの優先度順のキューイング 
(TA_TPRI) をサポートしている．

・メッセージバッファのサイズ (bufsz) は，大きい方に丸められる．丸める
単位は，INT型のデータ 1つ分のサイズ (TRON仕様チップの場合は，4バイト) 
である．

・メッセージの最大長 (maxmsg) が負または 0 の場合，E_PARエラーになる．

・メッセージバッファの領域は，cre_mbf 実行時に，システムメモリプールか
ら取られる．取れない場合には，E_NOMEMエラーとなる．

・システムログ用の mbfid = (-4) のメッセージバッファをサポートしている．
システムログ用のメッセージバッファは，ユーザタスク (リングレベル0 で動
いている場合を除く) からアクセスすることはできない．システムログ用メッ
セージバッファに送られたメッセージを処理するために，ログタスクを用意す
る (詳しくは，「システムログタスク」の項を参照)．

・デバッグサポート用の mbfid = (-3) のメッセージバッファを使うことがで
きるが，カーネルは特別なサポートはしていない．

(2) del_mbf		メッセージバッファ削除

(3) snd_mbf		メッセージバッファへ送信
(4) psnd_mbf		メッセージバッファへ送信 (ポーリング)
(5) tsnd_mbf		メッセージバッファへ送信 (タイムアウト有)

・psnd_mbf および tsnd_mbf(tmout = TMO_POL) を，タスク独立部ないしはディ
スパッチ禁止状態から実行することができる．

・メッセージは，バッファ中では INT型のデータ 1つ分のサイズ (TRON仕様チッ
プの場合は，4バイト) を単位に大きい方に丸めたサイズの領域を占有する．
さらに，メッセージを 1つ送信する度に，管理用のエリアとして，INT型のデー
タ 1つ分のエリアがメッセージバッファから取られる．ref_mbf で参照できる
空きバッファのサイズ (frbufsz) は，これらの分も減少することになる．

・タスクがメッセージ送信待ちの行列を作った場合に，待ち行列の中では後方
にあっても，送信しようとするメッセージサイズが小さく，メッセージバッファ
の残り領域に入るならば，後方のタスクが優先される．そのため，送信待ち行
列は，厳密には FIFO にならない．

(6) rcv_mbf		メッセージバッファから受信
(7) prcv_mbf		メッセージバッファから受信 (ポーリング)
(8) trcv_mbf		メッセージバッファから受信 (タイムアウト有)

・メッセージバッファからの受信によって，複数のタスクが同時にメッセージ
送信可能となり待ち解除される場合，メッセージバッファ中でのメッセージの
順序および待ち解除後のレディキュー中のタスクの順序については，元のメッ
セージバッファ送信待ち行列中での順序を保存する．

(9) ref_mbf		メッセージバッファ状態参照

・待ちタスクがある場合，wtsk，stsk には待ち行列の先頭のタスクの ID を
返す．

(10) cre_por		ランデブ用のポート生成

・呼出メッセージの最大長 (maxcmsg)，返答メッセージの最大長 (maxrmsg) 
が負または 0 の場合，E_PARエラーになる．

・ItIs では，cre_por をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．

(11) del_por		ランデブ用のポート削除

・ItIs では，del_por をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．

(12) cal_por		ポートに対するランデブの呼出
(13) pcal_por		ポートに対するランデブの呼出 (ポーリング)
(14) tcal_por		ポートに対するランデブの呼出 (タイムアウト有)

(15) acp_por		ポートに対するランデブ受付
(16) pacp_por		ポートに対するランデブ受付 (ポーリング)
(17) tacp_por		ポートに対するランデブ受付 (タイムアウト有)

(18) fwd_por		ポートに対するランデブ回送

(19) rpl_rdv		ランデブ返答

・ItIs では，ランデブ応答メッセージの長さを 0 にすることができる．

(20) ref_por		ポート状態参照

・待ちタスクがある場合，wtsk，atsk には待ち行列の先頭のタスクの ID を
返す．

・ItIs では，ref_por をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．


3.5. 割込み管理機能

(1) def_int		割込みハンドラ定義

・dintno は TRON仕様チップでの EITベクタ番号を表し，0x01 から 0xff ま
での値が使える．

・ターゲットによっては，pk_dint = NADR にして，前に定義した割込みハン
ドラの定義解除を行う機能はサポートしていない．その場合には，pk_dint =
NADR で呼び出すと，E_NOSPTエラーとなる．これは，ターゲットによっては，
ItIs が ROMモニタに依存して動作するように作られており，どのように戻せ
ばよいかを管理していないためである．

・外部割込み以外の EITベクタに対してハンドラを設定する機能は，ItIs で
実装されていない例外管理機能をユーザが作れるようにするための拡張であり，
利用するにあたっては，カーネルの構造を十分に理解していることが望まれる．

例外管理機能を作る際には，TRON仕様チップでの EITハンドラ情報を指定する
必要がある．例えば，コンテキストに依存して動作するハンドラの場合，SP0 
を使って動作させることが必要になる．

この設定を可能にするために，T_DINT構造体に eitatrフィールドを追加して
いる．割込みハンドラ属性に TA_EITATR を設定すると，eitatrフィールドの
値をそのまま EITベクタテーブルエントリの最初のワードに設定する．ちなみ
に，デフォルトでは，通常の割込みハンドラ用の EITハンドラ属性 
(0x000f0000) が設定される．

#define TA_EITATR	0x00010000	/* EIT属性を指定 */

(2) ret_int		割込みハンドラから復帰

・割込みハンドラからは，アセンブラの REIT命令，C言語の return や関数の
最後で自動的に復帰できるため，ret_int はサポートしない．他のシステムと
の互換性のために ret_int が必要になる場合は，以下の定義により代用でき
る (C言語の場合)．

#define ret_int()	{ ruturn; }

(3) ret_wup		割込みハンドラ復帰とタスク起床

・割込みハンドラからは，アセンブラの REIT命令，C言語の return や関数の
最後で自動的に復帰できるため，ret_wup はサポートしない．他のシステムと
の互換性のために ret_wup が必要になる場合は，以下の定義により代用でき
る (C言語の場合)．

#define ret_wup(tskid)	{ wup_tsk(tskid); return; }

(4) loc_cpu		割込みとディスパッチの禁止

・loc_cpu は，IMASK を 0 に設定する．

(5) unl_cpu		割込みとディスパッチの許可

・unl_cpu は，IMASK を 15 に設定する．

(6) dis_int		割込み禁止
(7) ena_int		割込み許可

・TRON仕様チップに ITRON を載せた場合，ディスパッチを許可したまま割込
みを禁止するには，周辺チップを操作する必要がある．周辺チップの操作は，
CPU ばかりでなく，ハードウェア構成に大きく依存するため，これらのシステ
ムコールはサポートしない．

(8) chg_ims		割込みマスク変更

・chg_ims は IMASK を指定した値に設定する．指定した値が 0〜15 以外の場
合，E_PARエラーとなる．タスク独立部から呼び出した場合には，IMASK を 7 
より大きい値に設定することはできない (設定しようとすると，E_PAR エラー
になる)．

・設定した IMASK の値と，ref_sys で参照できるタスク部のシステム状態
(sysstat) の関係は以下のようになる．

	IMASK		sysstat
	------------------------
	0〜13		TTS_LOC
	14		TTS_DDSP
	15		TTS_TSK

・タスク独立部から呼ばれた場合，指定した IMASK が 0〜7 以外の場合，
E_PARエラーとなる．これは，タスク独立部で IMASK を 7 より大きい値に設
定した場合，カーネルの動作が保証されなくなるためである．

(9) ref_ims		割込みマスク参照

・ref_ims は IMASK の現在値を読み出すシステムコールである．


3.6. メモリプール管理機能

(1) cre_mpl		可変長メモリプール生成

・可変長メモリプール属性 (mplatr) として，待ちタスクの優先度順のキュー
イング (TA_TPRI) をサポートしている．

・可変長メモリプールの管理アルゴリズムとして，first-fit の他に 
half-fit をサポートして可変長メモリプール属性 (mplatr) により選択可能
とする計画であるが，現バージョンでは first-fit しかサポートしていない．

・タスクがメモリ獲得待ちの行列を作った場合に，待ち行列の中では後方にあっ
ても，要求ブロックサイズが小さく，メモリプールからすぐにブロックが獲得
できるならば，後方のタスクが優先される (つまり，ITRON2 の TA_CNT に相
当)．そのため，メモリ獲得待ち行列は，厳密には FIFO ないしは優先度順に
はならない．

・メモリプール全体のサイズ (mplsz) は，大きい方に丸められる．丸める単
位は，ポインタ 4つ分のサイズ (TRON仕様チップの場合は，16バイト) である．

・可変長メモリプールの領域は，cre_mpl 実行時に，システムメモリプールか
ら取られる．取れない場合には，E_NOMEMエラーとなる．

・システム用の mplid = (-4) のメモリプールをサポートしている．システム
用メモリプールを生成，削除することはできないが，メモリブロックの獲得，
返却，メモリプールの状態参照をすることができる (μITRON3.0仕様では，メ
モリプールの状態参照のみできることになっている)．

(2) del_mpl		可変長メモリプール削除

(3) get_blk		可変長メモリブロック獲得
(4) pget_blk		可変長メモリブロック獲得 (ポーリング)
(5) tget_blk		可変長メモリブロック獲得 (タイムアウト有)

・pget_blk および tget_blk(tmout = TMO_POL) を，タスク独立部ないしはディ
スパッチ禁止状態から実行することができる．

・メモリブロックサイズ (blksz) は，大きい方に丸められる．丸める単位は，
ポインタ 2つ分のサイズ (TRON仕様チップの場合は，8バイト) である．

・可変長メモリブロックを 1つ獲得する度に，管理用のエリアとして，ポイン
タ 2つ分のエリア (TRON仕様チップの場合は，8バイト) がメモリプールから
取られる．さらに，残りエリアの管理の都合で，さらにポインタ 2つ分のエリ
アが取られる場合もある．ref_mpl で参照できる空き領域の合計サイズ 
(frsz) からは，これらの管理エリアの分も減少することになる．

(6) rel_blk		可変長メモリブロック返却

・メモリブロックの返却によって，複数のタスクが同時にメモリを獲得し待ち
解除される場合，待ち解除後のレディキュー中のタスクの順序については，元
のメモリプール待ち行列中での順序を保存する．

(7) ref_mpl		可変長メモリプール状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．

・ref_mpl は，最大空き領域のサイズを求めるためにメモリプール全体をスキャ
ンする．そのため，実行効率がかなり悪くなるので，デバッグ目的以外には使
わない方がよい．

・システム用メモリプールの状態をユーザタスク (リングレベル0 で動いてい
る場合を除く) から参照することはできない (μITRON3.0仕様では，ユーザタ
スクからも状態参照できることになっている)．

(8) cre_mpf		固定長メモリプール生成

・固定長メモリプール属性として，待ちタスクの優先度順のキューイング 
(TA_TPRI) をサポートしている．

・固定長メモリブロックサイズ (blksz) は，大きい方に丸められる．丸める
単位は，ポインタ 1つ分のサイズ (TRON仕様チップの場合は，4バイト) であ
る．

・固定長メモリプールの領域は，cre_mpf 実行時に，システムメモリプールか
ら取られる．取れない場合には，E_NOMEMエラーとなる．

(9) del_mpf		固定長メモリプール削除

(10) get_blf		固定長メモリブロック獲得
(11) pget_blf		固定長メモリブロック獲得 (ポーリング)
(12) tget_blf		固定長メモリブロック獲得 (タイムアウト有)

・pget_blf および tget_blf(tmout = TMO_POL) を，タスク独立部ないしはディ
スパッチ禁止状態から実行することができる．

(13) rel_blf		固定長メモリブロック返却

(14) ref_mpf		固定長メモリプール状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．


3.7. 時間管理機能

(1) set_tim		システムクロック設定

(2) get_tim		システムクロック参照

(3) dly_tsk		タスク遅延

(4) def_cyc		周期起動ハンドラ定義

・cycno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

・周期起動ハンドラ属性 (cycatr) に TA_HLNG を指定しても，実際には何も
しない．

・ItIs では，周期起動ハンドラは割込みが禁止された状態で起動されるため，
ハンドラ内では最小限の処理のみ行って，残りの処理はタスクに任せるように
作るべきである．

(5) act_cyc		周期起動ハンドラ活性制御

・cycno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

(6) ref_cyc		周期起動ハンドラ状態参照

・cycno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

(7) def_alm		アラームハンドラ定義

・almno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

・アラームハンドラ属性 (almatr) に TA_HLNG を指定しても，実際には何も
しない．

・アラームハンドラは，ハンドラ起動の時点 (厳密には起動する直前) で，自
動的に定義解除される．

・ItIs では，アラームハンドラは割込みが禁止された状態で起動されるため，
ハンドラ内では最小限の処理のみ行って，残りの処理はタスクに任せるように
作るべきである．

(8) ref_alm		アラームハンドラ状態参照

・almno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

(9) ret_tmr		タイマハンドラから復帰

・タイマハンドラからは，アセンブラの RTS命令，C言語の return や関数の
最後で自動的に復帰できるため，ret_tmr はサポートしない．他のシステムと
の互換性のために ret_tmr が必要になる場合は，以下の定義により代用でき
る (C言語の場合)．

#define ret_tmr()	{ ruturn; }


3.8. システム管理機能

(1) get_ver		バージョン参照

・現バージョンで参照される情報は以下の通り．

	maker	OS製造メーカ		0x0001	東京大学
	id	OS形式番号		0x5003	(深い意味はない)
	spver	仕様書バージョン番号	0x5302	μITRON，Ver.3.02
	prver	OS製品バージョン番号	0xXYYZ	Release X.YY.Z
	prno	製品管理情報		0....0	(未使用)
	cpu	CPU情報			0x0001	TRON仕様チップ共通
	var	バリエーション		0xc000	レベルE

(2) ref_sys		システム状態参照

・準タスク部実行中の場合は，sysstat に TTS_QTSK が返る．また，準タスク
部でディスパッチ禁止中の場合は (TTS_QTSK|TTS_DDSP)，準タスク部で割込み
およびディスパッチ禁止中の場合は (TTS_QTSK|TTS_LOC) が返る (ItIs での
拡張機能)．

・整理すると，sysstat は次のような値をとる．

	TTS_TSK			0
	TTS_TSK|TTS_DDSP	1
	TTS_TSK|TTS_LOC		3
	TTS_QTSK		8
	TTS_QTSK|TTS_DDSP	9
	TTS_QTSK|TTS_LOC	11
	TTS_INDP		4

・runtskid には，現在 RUN状態にあるタスクの ID が返る (RUN状態の定義に
ついては，「ref_tsk」の項を参照)．RUN状態のタスクがない場合には，FALSE 
が返される．

・schedtskid には，実行すべきタスクの ID が返る．実行すべきタスクとは，
スケジューリングの結果 RUN状態にすべきとされたタスクで，遅延ディスパッ
チの原則やディスパッチが禁止されている状態があるために，現在 RUN状態に
なっているタスクと一致するとは限らない．実行可能なタスクがない場合には，
FALSE が返る．

(3) ref_cfg		コンフィグレーション情報参照

・現バージョンでは，参照できる情報はない．

(4) def_svc		拡張SVCハンドラ定義

・s_fncd としては，1 からシステム構成設定ファイル中で設定した値までが
使える．それ以外の値を指定した時は，E_PARエラーとなる．

・pk_dsvc = NADR とした場合には，前に定義した拡張SVCハンドラの定義解除
を行う．既に定義済みの拡張機能コードに対して，拡張SVCハンドラを再定義
することができる．その際に，あらかじめ定義解除しておく必要はない．

・拡張SVCハンドラ属性 (svcatr) に TA_HLNG を指定しても，実際には何もし
ない．

(5) def_exc		例外ハンドラ定義

・サポートしない．


3.9. ネットワークサポート機能

・現バージョンではサポートしていない．


3.10. ID自動割当機能

(1) vcre_tsk	タスク生成 (ID自動割当)			    (機能コード: -241)

【パラメータ】
    T_CTSK*	pk_ctsk		タスク生成情報

【リターンパラメータ】
    ER		ercd		生成したタスクのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_tsk(T_CTSK *pk_ctsk);

【解説】
ID番号を指定せずにタスクを生成し，生成したタスクの ID (必ず正の値) を 
ercd に返す．ercd が負の場合は，エラーコードを表す．割り当て可能な ID 
がない場合，EV_FULLエラーとなる．その他については，cre_tsk と同じ．

(2) vcre_sem	セマフォ生成 (ID自動割当)		    (機能コード: -242)

【パラメータ】
    T_CSEM*	pk_csem		セマフォ生成情報

【リターンパラメータ】
    ER		ercd		生成したセマフォのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_sem(T_CSEM *pk_csem);

【解説】
ID番号を指定せずにセマフォを生成し，生成したセマフォの ID (必ず正の値) 
を ercd に返す．ercd が負の場合は，エラーコードを表す．割り当て可能な 
ID がない場合，EV_FULLエラーとなる．その他については，cre_sem と同じ．

(3) vcre_flg	イベントフラグ生成 (ID自動割当)		    (機能コード: -243)

【パラメータ】
    T_CFLG*	pk_cflg		イベントフラグ生成情報

【リターンパラメータ】
    ER		ercd		生成したイベントフラグのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_flg(T_CFLG *pk_cflg);

【解説】
ID番号を指定せずにイベントフラグを生成し，生成したイベントフラグの ID
(必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを表す．割
り当て可能な ID がない場合，EV_FULLエラーとなる．その他については，
cre_flg と同じ．

(4) vcre_mbx	メイルボックス生成 (ID自動割当)		    (機能コード: -244)

【パラメータ】
    T_CMBX*	pk_cmbx		メイルボックス生成情報

【リターンパラメータ】
    ER		ercd		生成したメイルボックスのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_mbx(T_CMBX *pk_cmbx);

【解説】
ID番号を指定せずにメイルボックスを生成し，生成したメイルボックスの ID
(必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを表す．割
り当て可能な ID がない場合，EV_FULLエラーとなる．その他については，
cre_mbx と同じ．

(5) vcre_mbf	メッセージバッファ生成 (ID自動割当)	    (機能コード: -245)

【パラメータ】
    T_CMBF*	pk_cmbf		メッセージバッファ生成情報

【リターンパラメータ】
    ER		ercd		生成したメッセージバッファのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_mbf(T_CMBF *pk_cmbf);

【解説】
ID番号を指定せずにメッセージバッファを生成し，生成したメッセージバッファ
の ID (必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを表
す．割り当て可能な ID がない場合，EV_FULLエラーとなる．その他について
は，cre_mbf と同じ．

(6) vcre_por	ランデブ用のポート生成 (ID自動割当)	    (機能コード: -246)

【パラメータ】
    T_CPOR*	pk_cpor		ランデブ用ポート生成情報

【リターンパラメータ】
    ER		ercd		生成したランデブ用ポートのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_por(T_CPOR *pk_cpor);

【解説】
ID番号を指定せずにランデブ用ポートを生成し，生成したランデブ用ポートの 
ID (必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを表す．
割り当て可能な ID がない場合，EV_FULLエラーとなる．その他については，
cre_por と同じ．

(7) vcre_mpl	可変長メモリプール生成 (ID自動割当)	    (機能コード: -247)

【パラメータ】
    T_CMPL*	pk_cmpl		可変長メモリプール生成情報

【リターンパラメータ】
    ER		ercd		生成した可変長メモリプールのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_mpl(T_CMPL *pk_cmpl);

【解説】
ID番号を指定せずに可変長メモリプールを生成し，生成した可変長メモリプー
ルの ID (必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを
表す．割り当て可能な ID がない場合，EV_FULLエラーとなる．その他につい
ては，cre_mpl と同じ．

(8) vcre_mpf	固定長メモリプール生成 (ID自動割当)	    (機能コード: -248)

【パラメータ】
    T_CMPF*	pk_cmpf		固定長メモリプール生成情報

【リターンパラメータ】
    ER		ercd		生成した固定長メモリプールのID, エラーコード

【C言語インタフェース】
    ER ercd =vcre_mpf(T_CMPF *pk_cmpf);

【解説】
ID番号を指定せずに固定長メモリプールを生成し，生成した固定長メモリプー
ルの ID (必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを
表す．割り当て可能な ID がない場合，EV_FULLエラーとなる．その他につい
ては，cre_mpf と同じ．

(9) vdef_cyc	周期起動ハンドラ定義 (ID自動割当)	    (機能コード: -255)

【パラメータ】
    T_DCYC*	pk_dcyc		周期起動ハンドラ定義情報

【リターンパラメータ】
    ER		ercd		定義した周期起動ハンドラの番号, エラーコード

【C言語インタフェース】
    ER ercd =vdef_cyc(T_DCYC *pk_dcyc);

【解説】
番号を指定せずに周期起動ハンドラを定義し，定義した周期起動ハンドラの 
番号 (必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを表
す．割り当て可能な番号がない場合，EV_FULLエラーとなる．また，pk_dcyc =
NADR として，周期起動ハンドラの定義解除を行う機能はない．その他につい
ては，def_cyc と同じ．

(10) vdef_alm	アラームハンドラ定義 (ID自動割当)	    (機能コード: -256)

【パラメータ】
    T_DALM*	pk_dalm		アラームハンドラ定義情報

【リターンパラメータ】
    ER		ercd		定義したアラームハンドラの番号, エラーコード

【C言語インタフェース】
    ER ercd =vdef_alm(T_DALM *pk_dalm);

【解説】
番号を指定せずにアラームハンドラを定義し，定義したアラームハンドラの 
番号 (必ず正の値) を ercd に返す．ercd が負の場合は，エラーコードを表
す．割り当て可能な番号がない場合，EV_FULLエラーとなる．また，pk_dalm =
NADR として，アラームハンドラの定義解除を行う機能はない．その他につい
ては，def_alm と同じ．


3.11. デバッグサポート機能

(1) vset_reg	タスクのレジスタ内容設定		    (機能コード: -225)

    vset_reg: Set Task Registers

【パラメータ】
    ID		tskid		タスクID
    T_REGS*	pk_regs		汎用レジスタの値を入れるパケット
    T_EIT*	pk_eit		PC と PSW の値を入れるパケット
    T_CREGS*	pk_cregs	制御レジスタの値を入れるパケット

  pk_regs の内容
    VW		r0		汎用レジスタ R0 の値
	  …
    VW		r14		汎用レジスタ R14 の値
    VW		sp		現在リングのスタックポインタの値

  pk_eit の内容
    VW		pc		PC (プログラムカウンタ) の値
    VW		psw		PSW の値

  pk_cregs の内容
    VW		csw		CSW の値
    VW		sp0		SP0 (リング0 のスタックポインタ) の値
    VW		sp1		SP1 (リング1 のスタックポインタ) の値
    VW		sp2		SP2 (リング2 のスタックポインタ) の値
    VW		sp3		SP3 (リング3 のスタックポインタ) の値
    VW		uatb		UATB の値
    VW		lsid		LSID の値

【リターンパラメータ】
    ER		ercd		エラーコード

【C言語インタフェース】
    ER ercd =vset_reg(ID tskid, T_REGS *pk_regs, T_EIT *pk_eit,
		      T_CREGS *pk_cregs);

【解説】
tskid で示されるタスクの，TCB の中およびシステムスタック上に置かれてい
るレジスタの内容を設定する．ただし ItIs では，システムコール実行中にも
タスク切替えが起こるため，設定するレジスタの値が，タスク部実行中の値で
あるとは限らない．

このシステムコールにより，コンテキストに依存したすべてのレジスタの値を
設定することができる．pk_regs により汎用レジスタ値，pk_eit により PC 
と PSW の値，pk_cregs により各種の制御レジスタの値を設定することができ
る．pk_regs, pk_eit あるいは pk_cregs の値を NADR とすることにより，対
応するレジスタの設定は行われない．

pk_regs, pk_cregs が共に NADR でない場合，pk_cregs に含まれている現在
リングのスタックポインタの値が有効になり，pk_regs のスタックポインタ指
定は無効になる．pk_cregs が NADR の場合には，pk_regs のスタックポイン
タの値が現在リング (PSW の値の変更により現在リングが変更される場合には，
変更後のリング) のスタックポインタに設定される．

UATB, LSID を持たない CPU で動作させた場合，pk_cregs の対応するフィー
ルドの値は無視される．

DORMANT状態のタスクに対してこのシステムコールを発行し，タスク起動直後
のレジスタの値を設定することができる．ただし R0 および R1 については，
sta_tsk により，それぞれタスク起動コード (stacd) およびタスク拡張情報
が入れられるため，このシステムコールで設定することはできない．

このシステムコールを用いて SP0 (リング0 のスタックポインタ) の値を変更
することは勧められない．どうしても変更したい場合には，カーネルの構造を
十分に理解していることが必要になる．その場合，pk_eit を NADR にして，
EITスタックフレームを全部自分で用意する方が間違いが起こりにくいだろう．
また，ItIs が将来バージョンアップした際に，関連部分の書き直しが必要に
なることを覚悟しなければならない．

このシステムコールを自タスクに対して用いることはできない (E_OBJエラー
になる)．また，タスク独立部から呼び出すこともできない (E_CTXエラーにな
る)．

【エラーコード(ercd)】
    E_OK	正常終了
    E_ID	不正ID番号 (tskidが不正あるいは利用できない)
    E_NOEXS	オブジェクトが存在していない (tskid のタスクが存在しない)
    E_OACV	オブジェクトアクセス権違反
    E_OBJ	オブジェクトの状態が不正 (対象タスクが自タスク)
    E_PAR	パラメータエラー (psw が不正)
    E_CTX	コンテキストエラー (タスク独立部からの発行)

(2) vget_reg	タスクのレジスタ内容参照		    (機能コード: -226)

    vget_reg: Get Task Registers

【パラメータ】
    ID		tskid		タスクID
    T_REGS*	pk_regs		汎用レジスタの値を入れるパケット
    T_EIT*	pk_eit		PC と PSW の値を入れるパケット
    T_CREGS*	pk_cregs	制御レジスタの値を入れるパケット

【リターンパラメータ】
    ER		ercd		エラーコード   

  pk_regs の内容
    VW		r0		汎用レジスタ R0 の値
	  …
    VW		r14		汎用レジスタ R14 の値
    VW		sp		現在リングのスタックポインタの値

  pk_eit の内容
    VW		pc		PC (プログラムカウンタ) の値
    VW		psw		PSW の値

  pk_cregs の内容
    VW		csw		CSW の値
    VW		sp0		SP0 (リング0 のスタックポインタ) の値
    VW		sp1		SP1 (リング1 のスタックポインタ) の値
    VW		sp2		SP2 (リング2 のスタックポインタ) の値
    VW		sp3		SP3 (リング3 のスタックポインタ) の値
    VW		uatb		UATB の値
    VW		lsid		LSID の値

【C言語インタフェース】
    ER ercd =vget_reg(T_REGS *pk_regs, T_EIT *pk_eit, T_CREGS *pk_cregs,
		      ID tskid);

【解説】
tskid で示されるタスクの，TCB の中およびシステムスタック上に置かれてい
るレジスタの内容を参照する．ただし ItIs では，システムコール実行中にも
タスク切替えが起こるため，参照するレジスタの値が，タスク部実行中の値で
あるとは限らない．

このシステムコールにより，コンテキストに依存したすべてのレジスタの値を
参照することができる．pk_regs により汎用レジスタ値，pk_eit により PC 
と PSW の値，pk_cregs により各種の制御レジスタの値を参照することができ
る．pk_regs, pk_eit あるいは pk_cregs の値を NADR とすることにより，対
応するレジスタの参照は行われない．

UATB, LSID を持たない CPU で動作させた場合，pk_cregs の対応するフィー
ルドの値は意味を持たない．

このシステムコールを自タスクに対して用いることはできない (E_OBJエラー
になる)．また，タスク独立部から呼び出すこともできない (E_CTXエラーにな
る)．

【エラーコード(ercd)】
    E_OK	正常終了
    E_ID	不正ID番号 (tskid が不正あるいは利用できない)
    E_NOEXS	オブジェクトが存在していない (tskid のタスクが存在しない)
    E_OACV	オブジェクトアクセス権違反
    E_OBJ	オブジェクトの状態が不正 (対象タスクが自タスク)
    E_CTX	コンテキストエラー (タスク独立部からの発行)


3.12. 性能評価用システム時刻参照機能

(1) vget_tim	性能評価用システム時刻参照		    (機能コード: -82)

    vget_tim: Get Time for Performance Evaluation

【パラメータ】
    SYSUTIME*	pk_utim		現在の性能評価用システム時刻を返すパケット

【リターンパラメータ】
    ER		ercd		エラーコード

  pk_utim の内容
    SYSUTIME    sysutim		現在の性能評価用システム時刻

【C言語インタフェース】
    ER ercd =vget_tim(SYSUTIME *pk_utim);

【解説】
現在の性能評価用システム時刻を読み出し，sysutim に返す．

性能評価用システム時刻は 1μ秒単位で返されるが，実際にどれだけの精度が
あるかは，ターゲットシステムに依存する．

【エラーコード(ercd)】
    E_OK	正常終了


3.13. 優先度継承セマフォ機能

優先度継承セマフォ機能をサポートするシステムコールは，以下の 8つである．
それぞれについての詳細については，「優先度継承セマフォ機能の仕様」を参
照のこと．

(1) vcre_pis	優先度継承セマフォ生成			    (機能コード: -257)
(2) vvcre_pis	優先度継承セマフォ生成 (ID自動割当)	    (機能コード: -259)
(3) vdel_pis	優先度継承セマフォ削除			    (機能コード: -258)
(4) vsig_pis	優先度継承セマフォ資源返却		    (機能コード: -264)
(5) vwai_pis	優先度継承セマフォ資源獲得		    (機能コード: -261)
(6) vpreq_pis	優先度継承セマフォ資源獲得 (ポーリング)	    (機能コード: -262)
(7) vtwai_pis	優先度継承セマフォ資源獲得 (タイムアウト有) (機能コード: -263)
(8) vref_pis	優先度継承セマフォ状態参照		    (機能コード: -260)


3.14. タスク付属メイルボックス機能

(1) vsnd_tmb	タスク付属メイルボックスへ送信		    (機能コード: -272)

    vsnd_tmb: Send Message to Task Mailbox

【パラメータ】
    ID		tskid		タスクID
    T_MSG*	pk_msg		メッセージパケットの先頭アドレス

【リターンパラメータ】
    ER		ercd		エラーコード

【C言語インタフェース】
    ER ercd =vsnd_tmb(ID tskid, T_MSG *pk_msg);

【解説】
tskid で示されたタスクに付属するメイルボックスに，pk_msg を先頭アドレ
スとするメッセージパケットを送信する．メッセージパケットの内容はコピー
されず，受信時には先頭アドレスのみが渡される．

対象タスクがタスク付属メイルボックスからの受信を待っていた場合には，対
象タスクの待ち状態が解除され，vsnd_tmb で指定した pk_msg がそのタスク
に送信されて，vrcv_tmb のリターンパラメータとなる．一方，対象タスクが
受信待ち状態でなければ，送信されたメッセージは，メイルボックス中のメッ
セージキューに入れられる．どちらの場合にも，tsnd_tmb 発行タスクは待ち
状態とはならない．

【補足説明】
pk_msg は，メッセージヘッダを含めたメッセージパケットの先頭アドレスで
ある．メッセージパケットの形式は，通常のメイルボックスと同一である．

【エラーコード(ercd)】
    E_OK	正常終了
    E_ID	不正ID番号 (tskid が不正あるいは利用できない)
    E_NOEXS	オブジェクトが存在していない (tskid のタスク存在しない)
    E_OACV	オブジェクトアクセス権違反 (システムオブジェクトをアク
		セスする権利を持たない環境からの発行で tskid < (-4))
    E_OBJ	オブジェクトの状態が不正 (対象タスクが自タスクまたは 
		DORMANT状態)

(2) vrcv_tmb	タスク付属メイルボックスから受信	    (機能コード: -269)
(3) vprcv_tmb	タスク付属メイルボックスから受信 (ポーリング)		(-270)
(4) vtrcv_tmb	タスク付属メイルボックスから受信 (タイムアウト有)	(-271)

    vrcv_tmb:	Receive Message from Task Mailbox
    vprcv_tmb:	Poll and Receive Message from Task Mailbox
    vtrcv_tmb:	Receive Message from Task Mailbox with Timeout

【パラメータ (vrcv_tmb, vprcv_tmb の場合) 】
    なし

【パラメータ (vtrcv_tmb の場合) 】
    TMO		tmout		タイムアウト指定

【リターンパラメータ】
    ER		ercd		エラーコード
    T_MSG*	pk_msg		メッセージパケットの先頭アドレス

【C言語インタフェース】
    ER ercd = vwai_pis(T_MSG **ppk_msg);
    ER ercd =vpreq_pis(T_MSG **ppk_msg);
    ER ercd =vtrcv_tmb(T_MSG **ppk_msg, TMO tmout);

【解説】
vrcv_tmb では，それを呼び出したタスクに付属するメイルボックスからメッ
セージを受信する．付属するメイルボックスにまだメッセージが送信されてい
ない場合には，本システムコールを発行したタスクは待ち状態となり，メッセー
ジの到着を待つ．一方，付属するメイルボックスに既にメッセージが入ってい
る場合には，メッセージキューの先頭にあるメッセージを 1つ取り出して，そ
れをリターンパラメータ pk_msg とする．

vprcv_tmb は，vrcv_tmb から待ち状態に入る機能を取り除いたシステムコー
ルであり，vrcv_tmb を実行した場合に待ち状態に入るかどうかのポーリング
を行う．vprcv_tmb システムコールのパラメータの意味は vrcv_tmb と同じで
ある．

vtrcv_tmb は，vrcv_tmb にタイムアウトの機能を付け加えたシステムコール
であり，tmout により待ち時間の最大値 (タイムアウト値) を指定することが
できる．タイムアウト指定が行われた場合，待ち解除の条件が満足されない 
(メッセージが到着しない) まま tmout の時間が経過すると，タイムアウトエ
ラー E_TMOUT となってシステムコールが終了する．tmout の指定方法は，他
のシステムコールと同様である．

【補足説明】
pk_msg は，メッセージヘッダを含めたメッセージパケットの先頭アドレスで
ある．メッセージパケットの形式は，通常のメイルボックスと同一である．

【エラーコード(ercd)】
    E_OK	正常終了
    E_PAR	パラメータエラー (tmout <= (-2))
    E_RLWAI	待ち状態強制解除 (待ちの間に rel_wai を受け付け)
    E_TMOUT	ポーリング失敗またはタイムアウト
    E_CTX	コンテキストエラー (タスク独立部またはディスパッチ禁止
		状態で実行)

(5) vref_tmb	タスク付属メイルボックス状態参照	    (機能コード: -268)

    vref_tmb:	Refer Task Mailbox Status

【パラメータ】
    ID		tskid		タスクID
    T_RTMB*	pk_rtmb		メイルボックス状態を返すパケットアドレス

【リターンパラメータ】
    ER		ercd		エラーコード

  pk_rpis の内容
    BOOL_ID	wtsk		タスクの待ちの有無
    T_MSG*	pk_msg		次に受信されるメッセージパケットの先頭アドレス

【C言語インタフェース】
    ER ercd =vref_tmb(T_RTMB *pk_rtmb, ID tskid);

【解説】
tskid で示されたタスクに付属するメイルボックスの各種の状態を参照し，リ
ターンパラメータとして次に受信されるメッセージ，タスクの待ちの有無を返
す．

wtsk は，tskid で示されたタスクが付属するメイルボックスで待っているか
どうかを示す．待っていない場合は wtsk = FALSE = 0 となる．待ちタスクが
ある場合は，wtsk としてタスクの ID を返す．

pk_msg は，次に vrcv_tmb を実行した場合に受信されるメッセージである．
メッセージキューにメッセージが無い時は，pk_msg = NADR = (-1) となる．
また，どんな場合でも，pk+msg = NADR と wtsk = FALSE の少なくとも一方は
成り立つ．

【補足説明】
vref_tmb と vprcv_tmb は，いずれも待ち状態に入ることなく次のメッセージ
を知るシステムコールである．しかし，vref_tmb が単に次のメッセージを参
照するシステムコールであるのに対して，vprcv_tmb の場合はメッセージがあ
る時に vrcv_tmb と同様の動作をする (メッセージを取り出してメッセージキュー
から削除する) という点が異なっている．

【エラーコード(ercd)】
    E_OK	正常終了
    E_ID	不正ID番号 (tskid が不正あるいは利用できない)
    E_NOEXS	オブジェクトが存在していない (tskid のタスク存在しない)
    E_OACV	オブジェクトアクセス権違反 (システムオブジェクトをアク
		セスする権利を持たない環境からの発行で tskid < (-4))
    E_OBJ	オブジェクトの状態が不正 (対象タスクが DORMANT状態)


４．システムタスクと標準の拡張SVC

この節では，ItIs が標準で動作させるシステムタスクおよびドライバと，そ
れらを利用するための拡張SVC について説明する．

この節の内容は，暫定的な仕様であり，今後大幅に変更される可能性がある．
特に，シリアルインタフェースドライバについては，仕様も含めて，完成度が
低いと考えている．


4.1. 初期化タスク

初期化タスクは最初に動作して，必要な初期化を行うためのタスクである．必
要な初期化を行うと，slp_tsk により待ち状態に入る．システム全体を安全に
停止させる場合には，初期化タスクを wup_tsk で起床させればよい．なお，
初期化タスクは最高優先度で動作する．

現バージョンでは，以下の初期化を行う．

 (a) シリアルインタフェースドライバを起動する．
 (b) システムログタスクを起動する．
 (c) 初期起動タスクを起動する．


4.2. シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルI/Oポートを扱うためのドライ
バである．拡張SVCハンドラおよび割込みハンドラで構成される．

用いる標準Cライブラリに依存した機能であるが，sysio.c をリンクすること
により，一緒にリンクされるタスクの標準入出力をシリアルインタフェースド
ライバ経由に切替えることができる．

シリアルインタフェースドライバを呼び出す拡張SVC の仕様は以下の通りであ
る．なお，これらの拡張SVC を，タスク独立部から呼び出すことはできない．
呼び出した場合には，E_CTXエラーとなる．

(1) ER_INT serial_read(int portid, char *buffer, unsigned int len)

portid で示されるシリアルポートから，lenバイトの文字列を読み込み，
buffer からの領域に入れる．実際に読み込んだ文字数を返す (正または 0)．
portid に 0 を指定すると，コンソールとして用いているシリアルポートを指
定したことになる．

(2) ER_INT serial_write(int portid, char *buffer, unsigned int len)

portid で示されるシリアルポートに，buffer からの lenバイトの文字列を書
き出す．実際に書き出した文字数を返す (正または 0)．portid に 0 を指定
すると，コンソールとして用いているシリアルポートを指定したことになる．

(3) ER_INT serial_ioctl(int portid, int req, int arg)

portid で示されるシリアルポートの制御情報を設定/解除する．portid に 0 
を指定すると，コンソールとして用いているシリアルポートを指定したことに
なる．

設定/解除できる制御情報は，

・エコーバックモード (ECHO)

    TRUE … エコーバックを行う
    FALSE … エコーバックを行わない

・入力モード (INPUT)

    RAW … serial_read で，長さの指定にかかわらず 1文字のみ読み込む．
    CANONICAL … serial_read で，改行コードが来るか，指定した長さまで
		 読み込む．

・改行モード (NEWLINE)

    TRUE … LF(line feed) を CR(carriage return) + LF に変換して出力する．
    FALSE … 上の変換を行わない．

・フロー制御モード (FLOWC)

    IXON … 送信側に対して，XON/XOFF によるフロー制御を行う．
    IXANY … 送信側に対して XON/XOFF によるフロー制御を行っている時に，
	     任意の文字で，停止状態を解除する．
    IXOFF … 受信側に対して，XON/XOFF によるフロー制御を行う．

req に設定するモードの種類 (ECHO/INPUT/NEWLINE/FLOWC)，arg に設定する
値を入れて呼び出すと，制御情報が設定される．モードの種類と GETCTL の論
理和を req に入れて呼び出すと，制御情報の現在値を，戻り値として取り出
すことができる．後者の場合，arg の値は無視される．

例1. シリアルポート1 のフロー制御を止める．

ercd = serial_ioctl(1, FLOWC, 0);

例2. コンソール用ポートの入力モードを取り出す．

mode = serial_ioctl(0, INPUT|GETCTL, 0);

serial_ioctl で用いる定数は，itis_ioctl.h 中で定義されている．

(4) ER serial_init(int portid)

portid で示されるシリアルポートを初期化する．

(5) ER serial_shutdown(int portid, int flush)

portid で示されるシリアルポートのシャットダウン処理をする．flush が 0 
以外の場合は，送信バッファの内容が空になるまでループで待つ．


4.3. システムログタスク

システムログタスクは，システムログ用メッセージバッファからメッセージを
取り出し，シリアルポートへ書き出す．メッセージを 1つ出力する毎に，改行
を行う．

システムログ用のメッセージバッファにアクセスできないタスクのために，シ
ステムログ用のメッセージバッファに文字列を送信するための拡張SVC を用意
している．また，この拡張SVC は，ログタスクが動作していない時に，システ
ムの低レベル文字出力ルーチンを使って，メッセージを出力する．拡張SVC の
仕様は以下の通りである．

(1) ER syslog_send(const char *string, int len)

string から lenバイトの文字列をシステムログとして書き出す．


4.4. 初期起動タスク

初期起動タスクは，最初に起動されるアプリケーションタスクである．カーネ
ルをインタラクティブに使う場合は，シェルないしはコマンドインタプリタが
初期起動タスクになる．

ItIs の現バージョンでは，xscheme を ITRON の主なシステムコールを呼び出
せるように拡張して，シェルの代わりに使っている．システムコールを呼び出
すために，システムコール同じ名前の関数を用意している．関数へ渡す引数は，
システムコールインタフェースに準じて決めている (詳細は省略)．

xscheme を動作させるためには，標準Cライブラリが必要である．また，
xscheme は標準では浮動少数点演算をサポートしているが，現バージョンのカー
ネルでは FPU をサポートしていないため，コンパイル時に -msoft-float
-DNO_FLOAT を定義して FPU命令を生成しないようにすると同時に，浮動少数
点演算を使う機能を外している．浮動少数点演算を使いたい場合には，以下の 
2つの方法がある．

(1) FPU を持つシステムの場合，-msoft-float -DNO_FLOAT を外してコンパイ
ルする．この場合，FPU を使うことのできるタスクは 1つのみに限られるため，
xscheme 以外のタスクは FPU を使ってはならないことになる．また，標準ラ
イブラリも FPU に対応したものを用いる必要がある．

(2) 浮動小数点演算パッケージを用いることとし，-DNO_FLOAT を外してコン
パイルする．この場合上記の制限はない．

この時に，GLIBC の浮動小数点用の printf ライブラリには，大量のスタック 
(約 40KB と言われている) を消費することが問題になる．これを考えて，各
タスクのスタックの大きさを決める必要がある．

xscheme はサイズが大きく，また実行効率もそれほど良くはないので，将来的
には別のものに交換する可能性が高い．


５．ItIs タスクサポートライブラリ

ItIs タスクサポートライブラリとして，以下の関数を用意している．この内
のいくつかは，システムタスクからも使われて，カーネルと一緒にリンクされ
る．

    void perror(char *prompt, ER ercd)
    void panic(char *prompt, ER ercd)
    void itis_perror(char *file, int line, char *expr, ER ercd)
    void itis_panic(char *file, int line, char *expr, ER ercd)
    char *itron_strerror(ER ercd)
    void __assert_fail(char *expr, char *file, int line, char *func)
    void syslog(int priority, char *format, ...)
    int setlogmask(int maskpri)
    INT sysstat()

これらのライブラリの仕様は暫定的なものであり，将来的には変更される可能
性が高い．


６．インストール・移植

6.1. ディレクトリ・ファイル構成

ディレクトリ構成は次の通り．

    include/	共通ヘッダファイル
	tron/	    TRON仕様チップ依存ヘッダファイル
	bsd/	    BSD UNIX シミュレーション環境依存ヘッダファイル
    kernel/	カーネルソースファイル
    systask/	システムタスクソースファイル
    libitis/	ItIsタスクサポートライブラリ
    tron/	TRON仕様チップ依存ファイル
	h32/	    Gmicro SBCシステム依存ファイル
	tvme/	    TVME-150依存ファイル
	mcube/	    MCUBE依存ファイル
	startup/    スタートアップモジュール (標準Cライブラリの一部)
    bsd/	BSD UNIX シミュレーション環境依存ファイル
	sunos4/	    SunOS 4.X依存ファイル
    sample/	設定サンプル (Makefile，システム構成設定ファイル)
    utils/	ユーティリティ
    doc/	ドキュメント

各ファイルの概要は次の通り．

    README		リリースメモ
    MINIFEST		配布ファイルの一覧
    ChangeLog		ItIs の変更履歴

    include/
	Makefile		ヘッダファイルインストール用 Makefile
	itron.h			ITRON の標準的な定義
	itron_errno.h		ITRON のエラーコードの定義
	itron_fncode.h		ITRON の機能コードの定義 (by genisyscall)
	itis_services.h		ItIsタスク用 標準インクルードファイル
	itis_isyscall.h		システムコールインタフェース (by genisyscall)
	itis_stddefs.h		ItIs で用いる共通的な定義
	itis_syslog.h		syslog ライブラリ用ヘッダファイル
	itis_debug.h		デバックサポート機能のための定義
	itis_ioctl.h		シリアルドライバの ioctl のための定義
	svc_fncode.h		拡張SVC の機能コードの定義
	svc_serial.h		シリアルドライバの拡張SVCインタフェース
	svc_syslog.h		システムログ送信の拡張SVCインタフェース

    include/tron/
	itis_scint.h		システムコール起動のための定義

    include/bsd/
	itis_scint.h		システムコール起動のための定義

    kernel/
	itable.S	システムコールディスパッチテーブル (by genisyscall)
	ptable.S	パラメータ処理ディスパッチテーブル (by genisyscall)
	isyscall.h	システムコールのプロトタイプ宣言 (by genisyscall)
	isysconf.h	システム構成のデフォルト値の定義
	itis_kernel.h	ItIsカーネル用 標準インクルードファイル
	check.h		各種のエラーチェック用マクロ
	queue.h		ダブルリンクキューの構造・操作の定義
	ready_queue.h	レディキューの構造・操作の定義
	timer.h		タイマ操作ルーチンの定義
	winfo.h		同期・通信オブジェクト毎に必要な待ち情報の定義
	task.h		タスク操作ルーチンの定義
	wait.h		タスク間同期・通信オブジェクト汎用ルーチンの定義
	patchlevel.h	リリース番号，パッチレベルの定義
	startup.c	システムスタートアップルーチン
	task_manage.c	タスク管理機能
	task_sync.c	タスク付属同期機能
	taskmbox.c	タスク付属メイルボックス機能
	semaphore.c	セマフォ機能
	eventflag.c	イベントフラグ機能
	mailbox.c	メイルボックス機能
	messagebuf.c	メッセージバッファ機能
	rendezvous.c	ランデブ機能
	prisem.c	優先度継承セマフォ機能
	mempool.c	可変長メモリプール管理機能
	mempfix.c	固定長メモリプール管理機能
	time_calls.c	時間管理機能
	misc_calls.c	その他のシステムコール
	debug_calls.c	デバッグサポート機能
	task.c		タスク操作ルーチン
	wait.c		待ち状態操作ルーチン
	timer.c		タイマ操作ルーチン
	isyslog.c	カーネル用 システムログ送信ライブラリ
	vsprintf.c	簡易 vsprintf関数
	syscall.def	システムコール定義ファイル
	genisyscall	システムコール定義生成プログラム
	genconfig	システム構成定義ファイル 生成プログラム
	newversion	version.c 生成プログラム

    systask/
	systask.h	システムタスク用 標準インクルードファイル
	inittask.c	初期化タスク
	serial.c	シリアルインタフェースドライバ
	logtask.c	システムログタスク
	sysio.c		カーネルと一緒にリンクするタスク用の入出力ルーチン
	bsd_sigio.c	BSD UNIX用 ノンブロッキングI/O サポートモジュール
	bsd_serial.c	BSD UNIX用 疑似シリアルドライバ

    libitis/
	Makefile	libitis 生成用 Makefile
	perror.c	perror 関数
	panic.c		panic 関数
	itis_perror.c	itis_perror 関数
	itis_panic.c	itis_panic 関数
	strerror.c	itron_strerror 関数
	assert_fail.c	__assert_fail 関数
	syslog.c	syslog 関数
	setlogmask.c	setlogmask 関数
	sysstat.c	sysstat 関数
	bsd_nbio.c	BSD UNIX用 ノンブロッキングI/Oライブラリ
	bsd_nbeio.c	BSD UNIX用 ノンブロッキングI/Oライブラリ (errno を返す)

    tron/
	Makefile.config	Makefile の共通定義
	cpu_conf.h	TRON仕様チップ用 構成記述ファイル
	cpu_status.h	システム状態判別/設定マクロ等の定義
	cpu_task.h	CPU に依存するタスク関連処理
	cpu_calls.c	CPU に依存するシステムコール
	cpu_util.c	CPU に依存するその他の関数
	cpu_support.S	CPU に依存するその他のルーチン
	dispatch.S	タスクディスパッチャ
	nd_dispatch.S	タスクディスパッチャ (遅延割込みを使わないバージョン)
	makeoffset.c	offset.h 生成サポートプログラム
	tron_defs.h	TRON仕様チップ依存の定数の定義
	tron_insn.h	低レベルの CPU操作ルーチン

    tron/h32/
	sys_conf.h	Gmicro SBCシステム用 構成記述ファイル
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン
	sys_timer.h	Gmicro SBCシステム用 タイマ操作ルーチン
	sys_serial.h	Gmicro SBCシステム用 シリアルI/O 操作ルーチン
	h32sbc.h	Gmicro SBCシステム ハードウェア定義

    tron/tvme/
	sys_conf.h	TVME-150 CPUボード用 構成記述ファイル
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン
	sys_timer.h	TVME-150 CPUボード用 タイマ操作ルーチン
	sys_serial.h	TVME-150 CPUボード用 シリアルI/O 操作ルーチン
	tvme150.h	TVME-150 CPUボード ハードウェア定義

    tron/mcube/
	sys_conf.h	MCUBE用 構成記述ファイル
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン
	sys_timer.h	MCUBE用 タイマ操作ルーチン
	sys_serial.h	MCUBE用 シリアルI/O 操作ルーチン
	mcube.h		MCUBE ハードウェア定義

    tron/startup/
	Makefile	スタートアップモジュール生成用 Makefile
	start.S		スタートアップモジュール (crt0.o のソース)

    bsd/
	Makefile.config	Makefile の共通定義
	cpu_conf.h	BSD UNIX用 構成記述ファイル
	cpu_status.h	システム状態判別/設定マクロ等の定義
	cpu_task.h	CPU に依存するタスク関連処理
	cpu_calls.c	CPU に依存するシステムコール
	cpu_util.c	CPU に依存するその他の関数
	cpu_support.S	CPU に依存するその他のルーチン (空ファイル)
	makeoffset.c	offset.h 生成サポートプログラム (空ファイル)
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン (空ファイル)
	sys_timer.h	Gmicro SBCシステム用 タイマ操作ルーチン

    bsd/sunos4/
	sys_conf.h	SunOS 4.X用 構成記述ファイル

    bsd/freebsd/
	sys_conf.h	FreeBSD用 構成記述ファイル

    sample/
	Makefile.h32	カーネルの Makefile のサンプル (Gmicro SBCシステム用)
	Makefile.tvme	カーネルの Makefile のサンプル (TVME-150 CPUボード用)
	Makefile.mcube	カーネルの Makefile のサンプル (MCUBE用)
	Makefile.sunos4	カーネルの Makefile のサンプル (SunOS 4.X用)
	config.def	システム構成設定ファイルのサンプル
	config.def.bsd	システム構成設定ファイルのサンプル (BSD UNIX用)

    utils/
	deldep		依存関係定義の削除
	makedep		依存関係定義の生成
	genoffset	offset.h 生成プログラム

    doc/
	USER		ユーザズマニュアル
	BSDUNIX		BSD UNIX 上での動作環境
	PRISEM		優先度継承セマフォ機能の仕様
	CONDITION	ItIs の配付・使用条件に関する FAQ


6.2. インストール

カーネルをインストールするには，ItIs の標準リリースに含まれる以外に，
以下のツール，ライブラリが必要である．

    TRON仕様チップ用 GNU開発環境
	GCC 2.6.3 Beta7.3 (Cコンパイラ)
	BINUTILS 2.5.2 (アセンブラ,リンカなど)
	GLIBC 1.09 (標準Cライブラリ)
    perl 4.XXX (動作確認は 4.036)
    GNU Make (動作確認は 3.72.1)
    extidata (a.out からデータセクションを取り出すツール)
    aout2 (a.out から Sフォーマットへの変換ツール)

TRON仕様チップ用 GLIBC (標準Cライブラリ) は，標準Cライブラリを使用する
タスクを動作させない場合には必要ない．その場合の注意については，「標準
Cライブラリとスタートアップモジュール」の項を参照すること．

extidata は，プログラム起動時にデータセクションの初期化を行いたい場合
に必要となる．ロードしたプログラムを何度も実行したい場合や，ROM化する
場合に用いる．aout2 は，a.outフォーマットのファイルが直接ダウンロード
できる場合には必要ない．

標準的なインストール手順は以下の通りである．

最初に，ItIs を展開したディレクトリに，オブジェクトファイルを置くため
のディレクトリを作る (ディレクトリ名は何でもよい)．

    % mkdir OBJ
    % cd OBJ

sample から，適当な Makefile と config.def をコピーし，内容を作りたい
カーネル用に編集する．

    % cp ../sample/Makefile.XXX Makefile
    % cp ../sample/config.def .
    % emacs Makefile config.def

Makefile の依存関係定義部を作ってから，オブジェクトを作る．

    % gmake depend
    % gmake


6.3. 標準Cライブラリとスタートアップモジュール

カーネルといっしょにリンクするいずれのタスクも標準Cライブラリを使用し
ない場合には，カーネルを作る際に標準Cライブラリをリンクする必要はない．
この場合，システム起動時に標準Cライブラリの初期化ルーチンを呼び出す必
要がなくなるため，スタートアップモジュール (tron/startup/start.S) およ
びそこから呼ばれるターゲットシステム依存のスタートアップルーチン 
(tron/$(SYS)/sys_support.S に含まれる) 中の該当部分を削除する必要があ
る．ItIs の標準リリースに含まれるスタートアップモジュールのソースコー
ドは，本来は標準Cライブラリの一部であり，あくまで参考のために ItIs の
リリースに含めている．

カーネルといっしょにリンクするタスクが標準Cライブラリを使う場合，カー
ネルとタスクのヒープ領域管理の衝突に注意する必要がある．具体的には，タ
スクが直接/間接的に sbrk関数を呼び出す場合には，カーネルで使用する 
sbrk関数 (ターゲット依存のスタートアップモジュールに含まれている) が呼
び出されることになる．そのため，カーネルが使用するヒープ領域に加えて，
タスクが使用する領域も計算に入れてメモリ配置を決定する必要がある．また
一般には，カーネルといっしょにリンクするタスクから brk関数を呼び出すこ
とはできない．


6.4. メモリマップと配置

ItIs 動作時には，以下のメモリエリアが必要になる．

(a) カーネルコード領域

カーネルのプログラムおよび定数データが置かれる領域．ROM上に置くことも
可能．先頭アドレスを，カーネルをリンクする際の -Ttext オプションで指定
する．

(b) タスク独立部用スタック領域

タスク独立部が使用するスタックの領域．スタック領域の末尾は，タスク独立
部用スタック (SPI) の初期値によって決まる．SPI は通常，ターゲットシス
テム依存のスタートアップルーチン (tron/$(SYS)/sys_support.S に含まれる) 
中で初期化される．

(c) カーネルデータ領域

カーネルの使用するデータ領域．固定的なデータ領域と，sbrk関数によって取
られるヒープ領域からなる．先頭アドレスを，カーネルをリンクする際の 
-Tdata オプションで指定する．

システム用メモリプール (mplid = (-4) のメモリプール) は，この領域から 
sbrk関数を使って取られる．システム用メモリプールのサイズを変更したい場
合は，システム構成設定ファイル中の sys_mpl_size で指定する．

(d) ユーザプログラム領域

ItIs カーネルは，ユーザプログラム領域の管理を行わないため，ユーザプロ
グラムはカーネルが使用しない任意のアドレスに置くことができる．

この他に，ターゲットによっては，ItIs用の EITベクタテーブルを用意する必
要がある．また，ROMモニタのワークエリアと ItIs の使用する領域が衝突し
ないよう注意が必要である．


6.5. 他のターゲットシステムへの移植

TRON仕様チップを用いた他のターゲットシステムに移植するために必要な作業
は，基本的には，ターゲットシステムの違いを吸収するためのモジュール (具
体的には，tron/$(SYS)/sys_conf.h, sys_util.c, sys_support.S,
sys_timer.h, sys_serial.h の 5つのファイルおよびそれらからインクルード
されるファイル) を作成することである．

その他，Makefile 等の変更も必要になる．詳しいことについては，別途相談
されたい．


6.6. 他の CPU への移植について

ItIs を他の CPU に移植するために必要な作業は，基本的には，ターゲット
CPU の違いを吸収するためのモジュール (具体的には，$(CPU) ディレクトリ
の下すべてと include/$(CPU)/itis_scint.h) を作成することである．その他
で TRON仕様チップの高機能命令を使った部分については，ターゲットCPU に
依存しない汎用コードを C言語で記述し，ifdef で区別している．

その他，移植先の CPU のアーキテクチャが TRON仕様チップと大きく異なる場
合には，カーネル本体の改造が必要になると思われる．詳しいことについては，
別途相談されたい．


７．その他

7.1. 配布・著作権

ItIs はフリーソフトウェアであり，配布自由である．著作権については，東
京大学坂村研究室が保有しているので，パブリックドメインソフトウェアでは
ない．具体的な配布条件は，各ファイルの先頭についている条件に従うものと
する (このドキュメントの先頭にもついている)．

ItIs の配付キットの最新版は，以下のアドレスから anonymous ftp ないしは 
WWW で取得することができる．

	ftp://tron.um.u-tokyo.ac.jp/pub/TRON/ItIs/
	http://tron.um.u-tokyo.ac.jp/TRON/ItIs/


7.2. 保証・サポート

ItIs はフリーソフトウェアであり，いかなる保証もできない．また，サポー
トの約束もできない．質問がある場合は，ItIs のユーザのためのメイリング
リスト (詳しくは「メイリングリスト」の項を参照) を利用されたい．

ItIs は研究・教育に利用することを目的として開発されているため，実装に
あたっては，実行性能よりも可読性や保守性を重視している．そのため，メー
カ製の同等のソフトウェアと比べて，性能的には劣るかもしれない．特に，割
込み禁止区間を短縮する努力をしていないため，最大割込み禁止時間はかなり
長くなっている．メッセージバッファ機能やランデブ機能でメッセージのコピー
を割込み禁止区間で行っているため，メッセージ長が長くなると最大割込み禁
止時間も長くなる．タスク応答性についても，同様のことが言える．また，製
品化されている ITRON仕様OS と比べると，テストは全く不十分である．


7.3. バグレポート

バグや問題点を発見した時の電子メイルによる連絡先は，以下の通り．

    itis-bug@tron.um.u-tokyo.ac.jp

実記憶で動作するカーネルの場合，カーネルのバグとアプリケーションのバグ
の切り分けは，一般には非常に難しい．この切り分けは，ユーザの責任である．
また，電話による問い合わせ等は受け付けない．


7.4. メイリングリスト

ItIs のユーザに対する情報提供およびユーザ相互間の情報交換を容易にする
ために，ItIsユーザのためのメイリングリストを用意している．メイリングリ
ストのアドレスは，

    itis-users@tron.um.u-tokyo.ac.jp

である．このメイリングリストへの登録を希望される場合は，氏名，所属，電
子メイルアドレス，電子メイル以外による連絡方法を以下に連絡されたい．

    itis-users-request@tron.um.u-tokyo.ac.jp


7.5. ITRON Club

仕事・勉強・趣味を問わず ITRON に興味を持つ人のための情報交換・議論の
場として，ITRON Club メイリングリストを用意している．このメイリングリ
ストには，ITRON に興味を持っている人なら誰でも参加できる．参加を希望さ
れる場合は，itron-club-request@tron.um.u-tokyo.ac.jp まで連絡されたい．

なお，このメイリングリストに送られたメイルは，後からメイリングリストに
参加された人に見せる場合がある．また，メイリングリストのメンバリストは，
メイリングリスト内で公開するので，あらかじめ了解頂きたい．


８．リファレンス

8.1. システムコール一覧

・タスク管理機能

    ER ercd = cre_tsk(ID tskid, T_CTSK *pk_ctsk);
    ER ercd = del_tsk(ID tskid);
    ER ercd = sta_tsk(ID tskid, INT stacd);
	 void ext_tsk();
	 void exd_tsk();
    ER ercd = ter_tsk(ID tskid);
    ER ercd = dis_dsp();
    ER ercd = ena_dsp();
    ER ercd = chg_pri(ID tskid, PRI tskpri);
    ER ercd = rot_rdq(PRI tskpri);
    ER ercd = rel_wai(ID tskid);
    ER ercd = get_tid(ID *p_tskid);
    ER ercd = ref_tsk(T_RTSK *pk_rtsk, ID tskid);

・タスク付属同期機能

    ER ercd = sus_tsk(ID tskid);
    ER ercd = rsm_tsk(ID tskid);
    ER ercd =frsm_tsk(ID tskid);
    ER ercd = slp_tsk();
    ER ercd =tslp_tsk(TMO tmout);
    ER ercd = wup_tsk(ID tskid);
    ER ercd = can_wup(INT *p_wupcnt, ID tskid);

・同期・通信機能

    ER ercd = cre_sem(ID semid, T_CSEM *pk_csem);
    ER ercd = del_sem(ID semid);
    ER ercd = sig_sem(ID semid);
    ER ercd = wai_sem(ID semid);
    ER ercd = preq_sem(ID semid);
    ER ercd = twai_sem(ID semid, TMO tmout);
    ER ercd = ref_sem(T_RSEM *pk_rsem, ID semid);
    ER ercd = cre_flg(ID flgid, T_CFLG *pk_cflg);
    ER ercd = del_flg(ID flgid);
    ER ercd = set_flg(ID flgid, UINT setptn);
    ER ercd = clr_flg(ID flgid, UINT clrptn);
    ER ercd = wai_flg(UINT *p_flgptn, ID flgid, UINT waiptn, UINT wfmode);
    ER ercd = pol_flg(UINT *p_flgptn, ID flgid, UINT waiptn, UINT wfmode);
    ER ercd =twai_flg(UINT *p_flgptn, ID flgid, UINT waiptn, UINT wfmode,
		      TMO tmout);
    ER ercd = ref_flg(T_RFLG *pk_rflg, ID flgid);
    ER ercd = cre_mbx(ID mbxid, T_CMBX *pk_cmbx);
    ER ercd = del_mbx(ID mbxid);
    ER ercd = snd_msg(ID mbxid, T_MSG *pk_msg);
    ER ercd = rcv_msg(T_MSG* *ppk_msg, ID mbxid);
    ER ercd =prcv_msg(T_MSG* *ppk_msg, ID mbxid);
    ER ercd =trcv_msg(T_MSG* *ppk_msg, ID mbxid, TMO tmout);
    ER ercd = ref_mbx(T_RMBX *pk_rmbx, ID mbxid);

・拡張同期・通信機能

    ER ercd = cre_mbf(ID mbfid, T_CMBF *pk_cmbf);
    ER ercd = del_mbf(ID mbfid);
    ER ercd = snd_mbf(ID mbfid, VP msg, INT msgsz);
    ER ercd =psnd_mbf(ID mbfid, VP msg, INT msgsz);
    ER ercd =tsnd_mbf(ID mbfid, VP msg, INT msgsz, TMO tmout);
    ER ercd = rcv_mbf(VP msg, INT *p_msgsz, ID mbfid);
    ER ercd =prcv_mbf(VP msg, INT *p_msgsz, ID mbfid);
    ER ercd =trcv_mbf(VP msg, INT *p_msgsz, ID mbfid, TMO tmout);
    ER ercd = ref_mbf(T_RMBF *pk_rmbf, ID mbfid);
    ER ercd = cre_por(ID porid, T_CPOR *pk_cpor);
    ER ercd = del_por(ID porid);
    ER ercd = cal_por(VP msg, INT *p_rmsgsz, ID porid, UINT calptn,
		      INT cmsgsz);
    ER ercd =pcal_por(VP msg, INT *p_rmsgsz, ID porid, UINT calptn,
		      INT cmsgsz);
    ER ercd =tcal_por(VP msg, INT *p_rmsgsz, ID porid, UINT calptn,
		      INT cmsgsz, TMO tmout);
    ER ercd = acp_por(RNO *p_rdvno, VP msg, INT *p_cmsgsz, ID porid,
		      UINT acpptn);
    ER ercd =pacp_por(RNO *p_rdvno, VP msg, INT *p_cmsgsz, ID porid,
		      UINT acpptn);
    ER ercd =tacp_por(RNO *p_rdvno, VP msg, INT *p_cmsgsz, ID porid,
		      UINT acpptn, TMO tmout);
    ER ercd = fwd_por(ID porid, UINT calptn, RNO rdvno, VP msg, INT cmsgsz);
    ER ercd = rpl_rdv(RNO rdvno, VP msg, INT rmsgsz);
    ER ercd = ref_por(T_RPOR *pk_rpor, ID porid);

・割込み管理機能

    ER ercd = def_int(UINT dintno, T_DINT *pk_dint);
    ER ercd = loc_cpu();
    ER ercd = unl_cpu();
    ER ercd = chg_ims(UINT imask);
    ER ercd = ref_ims(UINT *p_imask);

・メモリプール管理機能

    ER ercd = cre_mpl(ID mplid, T_CMPL *pk_cmpl);
    ER ercd = del_mpl(ID mplid);
    ER ercd = get_blk(VP *p_blk, ID mplid, INT blksz);
    ER ercd =pget_blk(VP *p_blk, ID mplid, INT blksz);
    ER ercd =tget_blk(VP *p_blk, ID mplid, INT blksz, TMO tmout);
    ER ercd = rel_blk(ID mplid, VP blk);
    ER ercd = ref_mpl(T_RMPL *pk_rmpl, ID mplid);
    ER ercd = cre_mpf(ID mpfid, T_CMPF *pk_cmpf);
    ER ercd = del_mpf(ID mpfid);
    ER ercd = get_blf(VP *p_blf, ID mpfid);
    ER ercd =pget_blf(VP *p_blf, ID mpfid);
    ER ercd =tget_blf(VP *p_blf, ID mpfid, TMO tmout);
    ER ercd = rel_blf(ID mpfid, VP blf);
    ER ercd = ref_mpf(T_RMPF *pk_rmpf, ID mpfid);

・時間管理機能

    ER ercd = set_tim(SYSTIME *pk_tim);
    ER ercd = get_tim(SYSTIME *pk_tim);
    ER ercd = dly_tsk(DLYTIME dlytim);
    ER ercd = def_cyc(HNO cycno, T_DCYC *pk_dcyc);
    ER ercd = act_cyc(HNO cycno, UINT cycact);
    ER ercd = ref_cyc(T_RCYC *pk_rcyc, HNO cycno);
    ER ercd = def_alm(HNO almno, T_DALM *pk_dalm);
    ER ercd = ref_alm(T_RALM *pk_ralm, HNO almno);

・システム管理機能

    ER ercd = get_ver(T_VER *pk_ver);
    ER ercd = ref_sys(T_RSYS *pk_rsys);
    ER ercd = ref_cfg(T_RCFG *pk_rcfg);
    ER ercd = def_svc(FN s_fncd, T_DSVC *pk_dsvc);

・ID自動割当機能

    ER ercd =vcre_tsk(T_CTSK *pk_ctsk);
    ER ercd =vcre_sem(T_CSEM *pk_csem);
    ER ercd =vcre_flg(T_CFLG *pk_cflg);
    ER ercd =vcre_mbx(T_CMBX *pk_cmbx);
    ER ercd =vcre_mbf(T_CMBF *pk_cmbf);
    ER ercd =vcre_por(T_CPOR *pk_cpor);
    ER ercd =vcre_mpl(T_CMPL *pk_cmpl);
    ER ercd =vcre_mpf(T_CMPF *pk_cmpf);
    ER ercd =vdef_cyc(T_DCYC *pk_dcyc);
    ER ercd =vdef_alm(T_DALM *pk_dalm);

・デバッグサポート機能

    ER ercd =vset_reg(ID tskid, T_REGS *pk_regs, T_EIT *pk_eit,
		      T_CREGS *pk_cregs);
    ER ercd =vget_reg(T_REGS *pk_regs, T_EIT *pk_eit, T_CREGS *pk_cregs,
		      ID tskid);

・性能評価用システム時刻参照機能

    ER ercd =vget_tim(SYSUTIME *pk_utim);

・優先度継承セマフォ機能

    ER ercd =vcre_pis(ID pisid, T_CPIS *pk_cpis);
    ER ercd =vvcre_pis(T_CPIS *pk_cpis);
    ER ercd =vdel_pis(ID pisid);
    ER ercd =vsig_pis(ID pisid);
    ER ercd =vwai_pis(ID pisid);
    ER ercd =vpreq_pis(ID pisid);
    ER ercd =vtwai_pis(ID pisid, TMO tmout);
    ER ercd =vref_pis(T_RPIS *pk_rpis, ID pisid);

・タスク付属メイルボックス機能

    ER ercd =vsnd_tmb(ID tskid, T_MSG *pk_msg);
    ER ercd =vrcv_tmb(T_MSG **ppk_msg);
    ER ercd =vprcv_tmb(T_MSG **ppk_msg);
    ER ercd =vtrcv_tmb(T_MSG **ppk_msg, TMO tmout);
    ER ercd =vref_tmb(T_RTMB *pk_rtmb, ID tskid);


8.2. エラーコード一覧 (カーネルが返すもののみ)

    E_OK	0		正常終了
    E_NOMEM	-10		メモリ不足
    E_NOSPT	-17		未サポート機能
    E_RSFN	-20		予約機能番号
    E_RSATR	-24		予約属性
    E_PAR	-33		パラメターエラー
    E_ID	-35		不正ID番号
    E_NOEXS	-52		オブジェクトが存在していない
    E_OBJ	-63		オブジェクトの状態が不正
    E_OACV	-66		オブジェクトアクセス権違反
    E_CTX	-69		コンテキストエラー
    E_QOVR	-73		キューイングのオーバーフロー
    E_DLT	-81		待ちオブジェクトが削除された
    E_TMOUT	-85		ポーリング失敗/タイムアウト
    E_RLWAI	-86		待ち状態強制解除
    EV_FULL	-225		オブジェクトテーブルフル


8.3. バージョン履歴

    1993年10月20日	Release1.1		最初のリリース版
    1993年11月8日	Release1.1 (PL=1)
    1993年12月10日	Release1.2		拡張機能のサポートを追加
    1993年12月24日	Release1.2 (PL=1)
    1994年1月17日	Release1.2 (PL=2)	β版とする
    1994年1月19日	Release1.2 (PL=3)
    1994年2月10日	Release1.2 (PL=4)
    1994年6月21日	Release1.2 (PL=5)
    1995年2月14日	Release1.3		CPU依存部を分離など大きく変更
    1995年3月15日	Release1.3 (PL=1)
    1995年6月19日	Release1.3 (PL=2)	ftp による一般公開を開始
    1996年2月17日	Release1.3 (PL=3)	(内部リリース)
    1998年1月30日	Release1.3 (PL=4)	Phase 3 最後の取りまとめ
