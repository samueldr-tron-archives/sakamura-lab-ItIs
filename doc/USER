
		＝ ItIs Phase4 ユーザズマニュアル ＝

	    （Release 1.4β対応，最終更新: 6-Jul-1998）


※ このユーザズマニュアルは，μITRON3.0標準ハンドブックの内容を前提に
書かれています．μITRON3.0標準ハンドブックを手元においてお読み下さい．

坂村 健 監修，「μITRON3.0標準ハンドブック 改訂新版」，パーソナルメディ
ア，1997，ISBN4-89362-154-8．

------------------------------------------------------------------------ 
	ItIs - An ITRON Implementation for Research and Education

Copyright (C) 1989-1997 by Sakamura Laboratory, Univ. of Tokyo, JAPAN
Copyright (C) 1997-1998 by Embedded and Real-Time Systems Laboratory,
				Toyohashi Univ. of Technology, JAPAN

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions
are met:
1. Redistributions of source code must retain the above copyright
   notice, this list of conditions and the following disclaimer.
2. Redistributions in binary form must reproduce the above copyright
   notice, this list of conditions and the following disclaimer in the
   documentation and/or other materials provided with the distribution.
3. Neither the names of the universities nor the names of the laboratories
   may be used to endorse or promote products derived from this software
   without specific prior written permission.

THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
IN NO EVENT SHALL THE UNIVERSITIES OR THE LABORATORIES BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER
IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

 * TRON は The Real-time Operating system Nucleus の略称です．
 * ITRON は Industrial TRON の略称です．
 * μITRON は Micro Industrial TRON の略称です．
 * ItIs は ITRON Implementation by Sakamura Lab の略称です．
------------------------------------------------------------------------


１．ItIs Phase4 の概要

ItIs Phase4（以下単に ItIs と書く）は，東京大学坂村研究室で研究・教育
用に開発が始められ，豊橋技術科学大学 組み込みリアルタイムシステム研究
室で開発が続けられている，μITRON3.0仕様に準拠したリアルタイムカーネル
である．現バージョンで，レベルE までのすべての機能（接続機能を除く）を
実現しており，いくつかの独自の拡張機能も持っている．今後徐々に，
μITRON4.0仕様準拠に書き直していく予定である．

このユーザズマニュアルでは，ターゲットCPU に依存しない機能についてのみ
説明している．ターゲットCPU に依存する機能については，ターゲットCPU 毎
のマニュアルを参照されたい．


1.1. ターゲットシステム，開発環境

ターゲットCPU として，現時点では，68040 と TRON仕様チップ（Gmicro/200 
と Gmicro/300 で動作確認）をサポートしている．CPU依存の部分を分離する
など，他の CPU への移植についても考慮しているが，どの程度の手間がかか
るかは移植先の CPU のアーキテクチャに大きく依存する．

開発環境としては，GCC などの GNU開発環境を用いている．GCC の拡張機能 
（long long 型，インラインアセンブラ機能など）に依存している部分があり，
他のコンパイラへの移植は単純ではない．

カーネル自身は，必要なライブラリをすべて含んでおり，標準Cライブラリは
必要としない．また，必要とする標準のヘッダファイルは，stdarg.h（可変数
引数を処理するため）と limits.h（INT_MAX を参照するため）のみである．
ただし，システムタスクが標準Cライブラリを必要とするケースもあるため，
カーネルに標準Cライブラリをリンクする構成を標準としている．

ターゲットシステムとしては，(株)電産製の DVE-68K/40 CPUボード（CPU:
68040 ないしは 68040LC）とアバールデータ社製の TVME-150 CPUボード 
（CPU: Gmicro/200）をサポートしている．他のターゲットシステムへの移植
の際は，ターゲット依存モジュールの書き直しが必要になる．


1.2. シミュレーション環境

ItIs のシミュレーション環境として，BSD UNIX上で動作する設定を用意して
いる．このシミュレーション環境は，BSD UNIX の 1つのプロセスの中で複数
のタスクを切り替えて動作させるもので，BSD UNIX上のスレッドライブラリと
して使うこともできる．ただし，サポートしている機能には限定がある．

現時点では，ターゲットシステムとして SunOS 4.X（Sparc）と FreeBSD（x86）
のみをサポートしているが，他の BSD UNIX への移植も可能である． BSD
UNIX に依存した機能を利用しているため，他の系列の UNIX への移植は手間
がかかるものと思われる．

BSD UNIX上でのシミュレーション環境についての詳細は，「BSD UNIX 上での
動作環境」を参照のこと．


1.3. サポートしない機能

実装依存機能である例外ハンドラの機能はサポートしていない．

現バージョンのカーネルは，FPU をサポートしていない（タスクディスパッチ
時などに，FPU レジスタを保存しない）．そのため，複数のタスクが FPU を使
用した場合の動作は保証されない．また，割込みハンドラなどのハンドラが 
FPU を使用する場合には，ユーザが FPU レジスタの保存・復帰を行う必要が
ある．


1.4. サポートしないシステムコール

以下のレベルC システムコールはサポートしていない．

    dis_int	割込み禁止
    ena_int	割込み許可
    def_exc	例外ハンドラ定義
	
また，以下のシステムコールは，他の方法で代用できるためサポートしない．

    ret_int	割込みハンドラからの復帰
    ret_wup	割込みハンドラ復帰とタスク起床
    ret_tmr	タイマハンドラからの復帰


1.5. μITRON3.0仕様に従っていない部分

ItIs は，以下の点でμITRON3.0仕様に従っていない．

・μITRON3.0仕様では，機能コードを表すデータ型 FN のサイズは最大 2バイ
トとしているが，ItIs では INT型（32bit CPU では 4バイトが普通）で扱っ
ている．これは，32bit CPU の場合，あえて 2バイトで扱うメリットが少ない
ためである．

・μITRON3.0仕様では，時間指定のためのデータ型 SYSTIME，CYCTIME，
ALMTIME のサイズは 48ビットを推奨しているが，ItIs ではこれらを GCC の 
long long 型（64ビットが普通）で扱っている．これは，GCC の long long 
型を用いた方がプログラムの見通しがよく，移植性の面からも有利であると考
えたためである．

・μITRON3.0仕様では，ユーザタスクがシステムオブジェクト（ID番号が負の
オブジェクト）をアクセスすると E_OACVエラーになるが，ItIs ではスーパバ
イザモードで動作しているユーザタスクからもシステムオブジェクトをアクセ
スすることができる．この仕様は，ユーザタスクをスーパバイザモードで動作
させる機能が追加されたと考えれば，拡張機能であると考えることもできる．

・μITRON3.0仕様では，タスクの優先度は，タスク起動時にタスク起動時優先
度に設定されるとしているが，ItIs では，タスク生成時およびタスク終了時
に設定される．これは，DORMANT状態のタスクに対して chg_pri を発行し，タ
スク起動直後の優先度を設定可能とするためである．この仕様は，外部仕様的
には，DORMANT状態のタスクに対する chg_pri を可能にしたという拡張機能に
なっている．

・μITRON3.0仕様では，ランデブの応答メッセージの長さが 0 の場合はエラー
とし，rpl_rdv が E_PARエラーを返すとしているが，ItIs では長さが 0 の応
答メッセージも使うことができる．これは，応答メッセージが不要な場合のた
めの仕様で，一種の拡張機能である．逆に，呼出しメッセージが不要な状況は
ほとんど考えられないため，呼出しメッセージの長さが 0 の場合はエラーと
している．

・μITRON3.0仕様では，mplid = (-4) のシステム用メモリプールをユーザタ
スクからも状態参照できることになっているが，ItIs ではスーパバイザモー
ド以外で動作しているタスクから状態参照することはできない．これには，深
い意味はない．


1.6. 拡張機能

ItIs は，μITRON3.0仕様に定義されている以外に，以下の拡張機能をサポー
トしている．拡張機能をサポートするかどうかは，システム構成設定ファイル
中で指定することができる．

(1) ID自動割当機能

μITRON3.0仕様では，オブジェクトを生成するシステムコールおよびタイマハ
ンドラを定義するシステムコールで，オブジェクトの ID ないしはタイマハン
ドラの番号を明示的に指定する必要がある．この仕様は，動作するタスクがあ
らかじめわかっているようなケース（ほとんどの組み込みシステムはこれに該
当する）には適当であるが，より大規模な OS のマイクロカーネルとして用い
るなど，動作するタスクがわからない場合には使いにくい．

ItIs では，オブジェクトの ID およびタイマハンドラの番号を，自動的に割
り当てる機能をサポートしている．オブジェクトの ID については，自動割当
の対象になるのは，正の ID のみである．この機能をサポートするために追加
されたシステムコールは次の通りである．

    vcre_tsk	タスク生成（ID自動割当）
    vcre_sem	セマフォ生成（ID自動割当）
    vcre_flg	イベントフラグ生成（ID自動割当）
    vcre_mbx	メイルボックス生成（ID自動割当）
    vcre_mbf	メッセージバッファ生成（ID自動割当）
    vcre_por	ランデブ用のポート生成（ID自動割当）
    vcre_mpl	可変長メモリプール生成（ID自動割当）
    vcre_mpf	固定長メモリプール生成（ID自動割当）
    vdef_cyc	周期起動ハンドラ定義（ハンドラ番号自動割当）
    vdef_alm	アラームハンドラ定義（ハンドラ番号自動割当）

(2) デバッグサポート機能

デバッグサポート機能とは，ItIs上で動作するタスクのデバッグを容易にする
ための機能で，主にデバッガで利用される機能である．現バージョンでは，以
下の 2つのシステムコールをサポートしている．

    vset_reg	タスクのレジスタ内容の設定
    vget_reg	タスクのレジスタ内容の参照

(3) 性能評価用システム時刻参照機能

性能評価用システム時刻参照機能とは，ItIs上で動作するタスクや ItIs 自身
の性能を計測するために，システム時刻をμ秒単位で読み出す機能である．こ
の機能をサポートするために追加されたシステムコールは次の通りである．

    vget_tim	性能評価用システム時刻の参照

(4) 優先度継承セマフォ機能

優先度継承セマフォとは，優先度継承プロトコルを実現するための同期オブジェ
クトである．現バージョンでは，バイナリセマフォのみをサポートしている．
この機能は，ITRON仕様カーネルで優先度継承プロトコルを実現するための機
構の研究の一貫として実装したもので，2通りの仕様を用意している．将来的
には，どちらかの仕様しかサポートしないケースや，どちらでもない第3の仕
様をサポートするケースも考えられる．この機能をサポートするために追加さ
れたシステムコールは次の通りである．

    vcre_pis	優先度継承セマフォ生成
    vvcre_pis	優先度継承セマフォの生成（ID自動割当）
    vdel_pis	優先度継承セマフォ削除
    vsig_pis	優先度継承セマフォ資源返却
    vwai_pis	優先度継承セマフォ資源獲得
    vpreq_pis	優先度継承セマフォ資源獲得（ポーリング）
    vtwai_pis	優先度継承セマフォ資源獲得（タイムアウト有）
    vref_pis	優先度継承セマフォ状態参照

(5) タスク付属メイルボックス機能

タスク付属メイルボックスとは，特定のタスクに付属し，そのタスクのみが受
信可能なメイルボックスである．この機能は，μITRON（ver 2.0）では定義さ
れていたが，μITRON3.0 では TCB を小さくし適応化を容易にするという理由
により，仕様から外されたものである．ItIs のタスク付属メイルボックス機
能は，μITRON（ver 2.0）の仕様を参考にして実装したものである．この機能
をサポートするために追加されたシステムコールは次の通りである．

    vsnd_tmb	タスク付属メイルボックスへ送信
    vrcv_tmb	タスク付属メイルボックスから受信
    vprcv_tmb	タスク付属メイルボックスから受信（ポーリング）
    vtrcv_tmb	タスク付属メイルボックスから受信（タイムアウト有）
    vref_tmb	タスク付属メイルボックス状態参照


２．全般

2.1. オブジェクトID

負のオブジェクトID はシステムオブジェクト，正のオブジェクトID はユーザ
オブジェクトを表す．(-4)〜0 のオブジェクトID は予約されており，システ
ムが利用するオブジェクトに割り当てられている場合を除いては，利用できな
い．

システムオブジェクトをアクセスする権利を持つのは，タスク独立部実行中，
準タスク部実行中，システムタスク（タスクID が負のオブジェクト）実行中
およびスーパバイザモードで動作しているユーザタスク実行中である（タスク
の動作モードについては，「cre_tsk」の項を参照）．μITRON3.0仕様の規定と
の違いは，正の ID のユーザタスクであっても，スーパバイザモードで動いて
いる場合には，システムタスクと同じアクセス権を持っていることである．シ
ステムオブジェクトをアクセスする権利を持たない環境から，システムオブジェ
クトをアクセスするシステムコールを発行した場合，E_OACVエラーとなる．

各オブジェクトの ID の範囲は，システム構成設定ファイル中で指定すること
ができる．オブジェクトの数を 0 にした場合（ID の最大値を最小値より 1 
小さい値にした場合），そのオブジェクトをサポートしないカーネルを作るこ
とができる．ただし現バージョンでは，カーネルやシステムタスクが使用して
いるオブジェクトの数を 0 にした場合の動作は保証しない．

オブジェクト以外で番号を持つ資源として，周期起動ハンドラ，アラームハン
ドラ，拡張SVCハンドラがある．これらの資源の番号は，1 から始まり，最大
値をシステム構成設定ファイル中で指定することができる．最大値を 0 にし
た場合，その資源をサポートしないカーネルを作ることができる．


2.2. 優先度値

優先度値の下限と上限は，システム構成設定ファイル中で指定することができ
る．(-4)〜0 の優先度は予約されており，利用できない．

優先度値のレベルを多くするとレディキューのサイズが大きくなるので注意が
必要である（256レベルで 2KB強になる）．


2.3. 時間パラメータ

ItIs では，時間を表すパラメータ（SYSTIME，CYCTIME，ALMTIME，DLYTIME，
TMO 型のもの）の基準時間を，すべて 1ミリ秒としている．

ハードウェアタイマによる周期割込みの間隔についても，1ミリ秒を標準とす
るが，ターゲットシステム依存のタイマモジュールのみの修正で変更できる．


2.4. エラーチェック

ItIs ではいくつかの種類のエラーについて，チェックするかどうかを，シス
テム構成設定ファイル中で指定することができる．現バージョンでは，指定で
きるエラーの種類は，以下の 9つである．これ以外のエラーは，必ずチェック
する．

    CHK_NOSPT:	未サポート機能（E_NOSPT）をチェックする．

    CHK_RSATR:	予約属性エラー（E_RSATR）をチェックする．

    CHK_PAR:	パラメータエラー（E_PAR）をチェックする．

    CHK_ID:	不正ID番号（E_ID）をチェックする．

    CHK_OACV:	オブジェクトアクセス権違反（E_OACV）をチェックする．

    CHK_CTX:	通常のコンテキストエラー（E_CTX）をチェックする．

    CHK_CTX1:	コンテキストエラー（E_CTX）の内，エラーの場合にもシス
		テムコールを発行したコンテキストに戻らないものをチェッ
		クする．具体的には，ext_tsk および exd_tsk がディスパッ
		チ禁止中に呼ばれた場合のコンテキストエラーをチェックす
		る．

    CHK_CTX2:	致命的なコンテキストエラー（E_CTX）が起こった時に，シ
		ステムを安全にダウンさせる．具体的には，タスク独立部か
		ら ext_tsk および exd_tsk が呼ばれた場合に，システムを
		ダウンさせる．

    CHK_SELF:	自タスクを対象として発行できないシステムコールを，自タ
		スクに対して発行した時に発生するエラー（E_OBJ）をチェッ
		クする．

チェックを省略したエラーが起こる条件でシステムコールを呼びだした場合の
動作は保証されない．

ItIs の現バージョンでは，カーネルが以下のエラーが報告することはない．

    E_SYS	システムエラー
    E_INOSPT	ITRON/FILE での未サポート機能
    E_MACV	メモリアクセス不能，メモリアクセス権違反
    EN_????	接続機能に関するエラー

また，パラメータとしてポインタを渡すシステムコールに対して，存在しない
メモリ番地をアクセスするようなポインタを渡した場合のエラーは，カーネル
では検出されない．そのような呼び出しをした場合，CPU がバスエラーを起こ
すことになる．


2.5. 準タスク部

準タスク部とは，タスクのコンテキストを持ちながらハンドラを実行している
状態のことをいう．準タスク部実行中は，タスクディスパッチが可能であり，
遅延割込みの原則は準タスク部には適用されない．また，準タスク部の中から，
自タスクを待ち状態にするシステムコールを発行することができる．

現バージョンでは，準タスク部になるのは，拡張SVCハンドラ実行中のみであ
る（ただし，タスク独立部から呼び出された拡張SVCハンドラ実行中は，準タ
スク部ではなく，タスク独立部であると扱われる）．

カーネルに準タスク部をサポートさせるかどうかは，システム構成設定ファイ
ル中で指定することができる．ただし，拡張SVCハンドラを使うという設定を
した場合，準タスク部をサポートするかどうかの指定にかかわらず，準タスク
をサポートするカーネルが作られる．


2.6. コンパイル時のオプション

カーネルのコード中には，assertマクロが使われている．assertマクロは， 
NDEBUG を定義することで，オブジェクトコード中から消すことができる．カー
ネルのデバッグが終了すれば，-DNDEBUG を指定してコンパイルした方が効率
がよくなる．

ItIs では，カーネルのサイズを最小限にし，他のライブラリに依存しないよ
うにするために，機能を縮小した簡易版の vsprintf関数である itis_vsprintf 
を用意している．デフォルトでは，カーネルと一緒にリンクされるタスクが呼
び出す syslog関数の中でも，itis_vsprintf を使うように設定されている．
タスクが呼び出す syslog関数からは標準Cライブラリ中の vsprintf を使わせ
たい場合には，syslog.c をコンパイルする際に，-Ditis_vsprintf=vsprintf 
というオプションをつければよい．

また，itis_vsprintf が long long 型の表示をサポートする必要がある場合，
vsprintf.c をコンパイルする際に -DUSE_LONGLONG を指定する．


2.7. システムコールインタフェース

ItIs では，タスクからシステムコールを呼び出すインタフェースとして，ソ
フトウェア割込みによるものと，サブルーチンコールによるものの両方を利用
することができる．ただし，サブルーチンコールによるインタフェースを用い
ることができるのは，スーパバイザモードで動いているタスクのみである．こ
れは，カーネルはスーパバイザモードで動作する必要があるが，サブルーチン
コールでは動作モードを変えられないためである．

システムコールインタフェースを決める際には，C言語から呼び出した場合の
効率を重視した．そのため，アセンブラインタフェースについては，
μITRON3.0仕様での推奨に従わなくなっている．

(1) ソフトウェア割込みを使うインタフェース

ソフトウェア割込みを使ったインタフェースの場合，動作モードが変わる可能
性があるため，スタック上にパラメータを置くインタフェースは望ましくない．
そこで，コンパイラがパラメータをスタック上に置く場合には，システムコー
ルを呼び出す前にスタック上のパラメータをレジスタに転送し，呼び出された
後にその逆の作業をする必要がある．

エラーコード以外のリターンパラメータを返す場合には，リターンパラメータ
を入れる領域へのポインタをパラメータとして渡す（μITRON3.0仕様の C言語
インタフェースにあわせた）．

(2) サブルーチンコールを使うインタフェース

システムコール xxx_yyy を呼び出す関数名を，i_xxx_yyy とする．名前の違
いを吸収するヘッダファイルを用意しているので，タスクからは xxx_yyy の
形で呼び出せばよい．パラメータの渡し方，エラーコードの受け取り方は，コ
ンパイラのコーリングコンベンションに従う．

サブルーチンコールを使うインタフェースを利用する場合，ItIsアプリケーショ
ン用の標準インクルードファイル（itis_services.h）をインクルードする前
に，LINK_KERNEL を定義しておく．


2.8. タスク，ハンドラの起動インタフェース

ItIs では，タスクやハンドラを C言語で記述することを標準と考え，なるべ
く，コンパイラのコーリングコンベンションにあわせて起動インタフェースを
定めている．ただし，タスクの起動インタフェースについては，スタートアッ
プモジュール（crt0.o）でスタックを扱うことが危険であること，割込みハン
ドラについては，オーバヘッドが問題になる場合があることから，必要に応じ
てアセンブラ用の起動インタフェースも用意する．タイマハンドラと拡張SVC
ハンドラに対しては，C言語のための高級言語対応ルーチンは用いておらず，
属性に TA_HLNG を指定しても実際には何もしない．

(1) タスク

タスクを C言語で記述する時は，タスク属性に TA_HLNG を指定し，タスクの
メインルーチンは，

	void	task(INT stacd, VP exinf)

の形で定義する．拡張情報が必要ない場合は，VP exinf は省略できる．タス
クを終了する場合は，ext_tsk ないしは exd_tsk を用いる．単に return し
た場合の動作は保証されない．

タスク属性に TA_HLNG を指定しない場合の動作は，ターゲットCPU 毎に定め
る．

(2) タイマハンドラ（周期起動ハンドラ，アラームハンドラ）

μITRON3.0仕様では，タイマハンドラに渡されるパラメータはないが，ItIs 
では，タイマハンドラの拡張情報が渡される．タイマハンドラを C言語で記述
する時は，タイマハンドラ本体は，

	void	timer_handler(VP exinf)

の形で定義する．拡張情報が必要ない場合は，VP exinf は省略できる．タイ
マハンドラから戻る際は，単に return する．互換性のために，タイマハンド
ラ属性に TA_HLNG を指定することが望ましい．

(3) 拡張SVCハンドラ

拡張SVCハンドラを C言語で記述する時は，拡張SVCハンドラ本体は，

	ER	svc_handler(INT par1, INT par2, ..., INT par6)

の形で定義する．拡張SVCに渡すことができるパラメータは最大6つで，拡張
SVCハンドラを定義する時には，必要な数だけ記述すればよい．拡張SVCハンド
ラから戻る際は，単に return する．互換性のために，拡張SVCハンドラ属性
に TA_HLNG を指定することが望ましい．

なお，サブルーチンコールを使ったインタフェースで拡張SVCハンドラを呼ぶ
方法については，特別なサポートはしていないが，拡張SVCハンドラとそれを
呼び出すルーチンが一緒にリンクされるならば，通常の関数呼び出しの方法で
呼び出すことができる（サブルーチンコールを使ってシステムコールを呼び出
せるのは，スーパバイザモードで動いているタスクのみであることに留意せよ）．

また，タスク独立部から拡張SVCハンドラを呼ぶことも可能である．タスク独
立部から呼ばれた拡張SVCハンドラ実行中は，準タスク部ではなく，タスク独
立部であると扱われるため，注意が必要である．

(4) 割込みハンドラ

ItIs では，割込みハンドラ属性に TA_HLNG を指定した場合（C言語で記述し
た関数が破壊するレジスタを保存するために，高級言語対応ルーチンは不可欠
である），第1引数に割込みスタックフレームの先頭番地が渡される．割込み
ハンドラを C言語で記述する時は，割込みハンドラ属性に TA_HLNG を指定し，
割込みハンドラ本体は，

	void	interrupt_handler(VP pk_eit)

の形で定義する．割込みスタックフレームの先頭番地が必要ない場合は，VP
pk_eit は省略できる．割込みハンドラから復帰するための処理は高級言語対
応ルーチン中に書かれているので，割込みハンドラから戻る際は，単に 
return する．

割込みハンドラ属性に TA_HLNG を指定しない場合の動作は，ターゲットCPU 
毎に定める．

2.9. タスク独立部から発行できるシステムコール

μITRON3.0仕様では，タスク独立部から発行できるシステムコールはインプリ
メント依存としているが，ItIs の現バージョンでは，仕様書で明示的に発行
できないとされているシステムコールに加えて，以下に挙げるシステムコール
をタスク独立部から呼び出すことはできない．これ以外のシステムコールは，
すべてタスク独立部から呼び出すことができる．

    他タスク強制終了（ter_tsk）
    ランデブ用ポートの生成・削除・参照（cre_por，del_por，ref_por，vcre_por）
    タスクのレジスタ内容の設定・参照（vset_reg，vget_reg）

ter_tsk をタスク独立部から呼び出せるように改造することも可能であるが，
有用性とオーバーヘッドを比べた場合に，それほどメリットはないと考えた．
また将来的には，cre_???，del_???，一部の def_???，一部の ref_??? など
のシステムコールをタスク独立部から呼ぶことを禁止するかもしれない．

μITRON3.0仕様で認められているタスク独立部からシステムコールを呼ぶ場合
に i???_??? の名称を用いるという方法は採用していない．


３．システムコール

以下では，各システムコールの仕様について，μITRON3.0仕様でインプリメン
ト依存となっている部分および ItIs での拡張機能を中心に述べる．


3.1. タスク管理機能

(1) cre_tsk		タスク生成

・タスク属性（tskatr）の内，コプロセッサに関するものはサポートしていな
い．指定すると E_RSATRエラーになる．

・システムスタックのサイズは，システム全体で固定したデフォルト値を用い
る方法と，cre_tsk でタスク毎に指定する方法がある．前者の方法で，システ
ム全体でのデフォルト値を変更したい場合は，システム構成設定ファイル中の 
def_sys_stack_size で指定する．タスク毎に指定する場合は，タスク属性に 
TA_SSTKSZ を設定し，T_CTSK構造体の sstkszフィールドに指定するサイズを
入れる．この場合，指定したシステムスタックのサイズが小さすぎる場合には，
E_PARエラーとなる．

#define TA_SSTKSZ	0x00010000	/* システムスタックサイズを指定 */

・タスクをどの動作モードで実行するかは，次の方法で決める．タスクID が
負の場合には，そのタスクはシステムタスクであると考えてスーパバイザモー
ドで実行する．正の場合には，タスク属性により，どの動作モードで実行する
かを指定することができる．タスク属性と動作モードの具体的な対応は，ター
ゲットCPU 毎に定める．

・タスクをスーパバイザモードで動かす場合には，ユーザスタックとシステム
スタックは区別されない．この場合，両者のサイズを加えたサイズのスタック
領域が確保される．

・ユーザスタックおよびシステムスタックの領域は，cre_tsk 実行時に，シス
テムメモリプールから取られる．取れない場合には，E_NOMEMエラーとなる．

・ユーザスタックのサイズに 0 を指定した場合，カーネルはユーザスタック
エリアを確保しない．ユーザが自分でスタック領域を決めたい場合には，ユー
ザスタックのサイズに 0 を指定し，タスク起動後にスタックポインタの初期
値を変更すればよい．

(2) del_tsk		タスク削除

(3) sta_tsk		タスク起動

・ItIs では，タスクの優先度は，タスク起動時ではなく，タスク生成時およ
びタスク終了時に，タスク起動時優先度に設定される．

(4) ext_tsk		自タスク終了

・ext_tsk が検出する E_CTXエラーは，システムログに記録する．タスク独立
部から ext_tsk を呼び出した場合，システムダウンする（CHK_CTX2 を指定し
た場合）．

・優先度継承セマフォ機能を用いている場合には，タスクの終了によって，獲
得している優先度継承セマフォが自動的に解放される場合がある．詳しくは，
「優先度継承セマフォ機能の仕様」を参照のこと．

(5) exd_tsk		自タスクの終了と削除

・exd_tsk が検出する E_CTXエラーは，システムログに記録する．タスク独立
部から exd_tsk を呼び出した場合，システムダウンする（CHK_CTX2 を指定し
た場合）．

・優先度継承セマフォ機能を用いている場合には，タスクの終了によって，獲
得している優先度継承セマフォが自動的に解放される場合がある．詳しくは，
「優先度継承セマフォ機能の仕様」を参照のこと．

(6) ter_tsk		他タスク強制終了

・ItIs では，ter_tsk をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．

・優先度継承セマフォ機能を用いている場合には，タスクの終了によって，獲
得している優先度継承セマフォが自動的に解放される場合がある．また，タス
クの強制終了によって待ち状態が解除されるのに伴って，他のタスクの優先度
が変更される場合がある．詳しくは，「優先度継承セマフォ機能の仕様」を参
照のこと．

(7) dis_dsp		ディスパッチ禁止

(8) ena_dsp		ディスパッチ許可

(9) chg_pri		タスク優先度変更

・tskpri として TSK_INI を指定して，タスク起動時優先度に戻す機能をサポー
トしている．

・ItIs では，DORMANT状態のタスクに対してこのシステムコールを発行し，タ
スク起動直後の優先度を設定することができる．タスクの優先度は，タスク生
成時およびタスク終了時に，タスク起動時優先度に設定される．そのため，こ
のシステムコールが E_OBJエラーを返すことはない．

・優先度継承セマフォ機能を用いている場合には，指定した以外のタスクの優
先度も変更される場合がある．詳しくは，「優先度継承セマフォ機能の仕様」
を参照のこと．

(10) rot_rdq		タスクのレディキュー回転

・タスク独立部から tskpri = TPRI_RUN を指定して rot_rdq を発行すること
が可能で，その場合，レディキュー中の最高優先度のタスクを含むレディキュー
を回転させる．

・自タスクが属するレディキューを回転させた場合でも，ディスパッチ禁止の
設定や，割込みがかかるタイミング等の要因により，自タスクが同じ優先度の
タスク中の最後に移動するとは限らない．自タスクを同じ優先度のタスク中の
最後に移動させたい場合は，chg_pri を使って自タスクの優先度を現在値に設
定しなおす方法が確実である．

(11) rel_wai		他タスクの待ち状態解除

・優先度継承セマフォ機能を用いている場合には，タスクの待ち状態が解除さ
れるのに伴って，他のタスクの優先度が変更される場合がある．詳しくは，
「優先度継承セマフォ機能の仕様」を参照．

(12) get_tid		自タスクのタスクID参照

(13) ref_tsk		タスク状態参照

・以下のインプリメント依存の情報が参照できる．

	tskwait		待ち要因
	wid		待ちオブジェクトID
	wupcnt		起床要求キューイング数
	suscnt		SUSPEND要求ネスト数

・CPU がコンテキストを持っているタスクを RUN状態であるとする．つまり，
RUN状態のタスクは，タスクディスパッチにより切り替わることになる．その
ため，遅延ディスパッチの原則やディスパッチの禁止によりディスパッチが遅
延されている間は，ディスパッチ前のタスクが RUN状態となる．

例えば，割込みハンドラから RUN状態のタスクに対して sus_tsk を発行した
後に，同じハンドラ内でそのタスクの状態を ref_tsk で参照した場合，発行
した sus_tsk によりタスクが強制待ち状態に移行する場合にも，遅延ディス
パッチの原則により ref_tsk は tskstat に TTS_RUN を返す．

・tskwait が (TTW_CAL|TTW_RDV) になることはない．


3.2. タスク付属同期機能

(1) sus_tsk		他タスクを強制待ち状態へ移行

・SUSPEND要求のネストの機能をサポートしている．ネスト回数の制限値は，
INT型で表現できる最大値である．

(2) rsm_tsk		強制待ち状態のタスクを再開
(3) frsm_tsk		強制待ち状態のタスクを強制再開

・RUN，READY状態のタスクが sus_tsk により SUSPEND状態になった後，
rsm_tsk，frsm_tsk によって実行を再開した場合，レディキューの該当優先度
の最後に入る．

(4) slp_tsk		自タスクを起床待ち状態へ移行

(5) tslp_tsk		自タスクを起床待ち状態へ移行（タイムアウト有）

・tmout = 0 で呼び出すことにより，slp_tsk に対するポーリングを行うこと
ができる．

(6) wup_tsk		他タスクの起床

・起床要求のキューイング数の制限値は，INT型で表現できる最大値である．

(7) can_wup		タスクの起床要求を無効化


3.3. 同期・通信機能

(1) cre_sem		セマフォ生成

・セマフォ属性として，待ちタスクの優先度順のキューイング（TA_TPRI）を
サポートしている．

・isemcnt と maxcnt を指定する機能をサポートしている．

(2) del_sem		セマフォ削除

(3) sig_sem		セマフォ資源返却

・セマフォの最大値（maxcnt）をチェックする機能をサポートしている．

(4) wai_sem		セマフォ資源獲得
(5) preq_sem		セマフォ資源獲得（ポーリング）
(6) twai_sem		セマフォ資源獲得（タイムアウト有）

(7) ref_sem		セマフォ状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．

(8) cre_flg		イベントフラグ生成

・イベントフラグ属性として，複数タスクの待ちを許すイベントフラグ 
（TA_WMUL）をサポートしている．

(9) del_flg		イベントフラグ削除

(10) set_flg		イベントフラグのセット
(11) clr_flg		イベントフラグのクリア

(12) wai_flg		イベントフラグ待ち
(13) pol_flg		イベントフラグ待ち（ポーリング）
(14) twai_flg		イベントフラグ待ち（タイムアウト有）

(15) ref_flg		イベントフラグ状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．

(16) cre_mbx		メイルボックス生成

・メイルボックス属性として，待ちタスクの優先度順のキューイング 
（TA_TPRI）およびメッセージの優先度順のキューイング（TA_MPRI）をサポー
トしている．

・メイルボックスは線形リストによって管理しているため，リングバッファの
大きさを指定するための bufcnt は使わない．

(17) del_mbx		メイルボックス削除

(18) snd_msg		メイルボックスへ送信

・メイルボックスは線形リストによって管理しているため，メッセージの先頭
に，カーネルが使用するリンクおよびメッセージ優先度を入れるためのヘッダ
領域が必要である．

・同じ理由により，E_QOVRエラーは起こらない．

(19) rcv_msg		メイルボックスから受信
(20) prcv_msg		メイルボックスから受信（ポーリング）
(21) trcv_msg		メイルボックスから受信（タイムアウト有）

・メイルボックスは線形リストによって管理しているため，メッセージの先頭
に，カーネルが使用するリンクおよびメッセージ優先度を入れるためのヘッダ
領域が必要である．

(22) ref_mbx		メイルボックス状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．


3.4. 拡張同期・通信機能

(1) cre_mbf		メッセージバッファ生成

・メッセージバッファ属性として，待ちタスクの優先度順のキューイング 
（TA_TPRI）をサポートしている．

・メッセージバッファのサイズ（bufsz）は，大きい方に丸められる．丸める
単位は，INT型のデータ 1つ分のサイズである．

・メッセージの最大長（maxmsg）が負または 0 の場合，E_PARエラーになる．

・メッセージバッファの領域は，cre_mbf 実行時に，システムメモリプールか
ら取られる．取れない場合には，E_NOMEMエラーとなる．

・システムログ用の mbfid = (-4) のメッセージバッファをサポートしている．
システムログ用のメッセージバッファは，ユーザタスク（スーパバイザモード
で動いている場合を除く）からアクセスすることはできない．システムログ用
メッセージバッファに送られたメッセージを処理するために，ログタスクを用
意する（詳しくは，「システムログタスク」の項を参照）．

・デバッグサポート用の mbfid = (-3) のメッセージバッファを使うことがで
きるが，カーネルは特別なサポートはしていない．

(2) del_mbf		メッセージバッファ削除

(3) snd_mbf		メッセージバッファへ送信
(4) psnd_mbf		メッセージバッファへ送信（ポーリング）
(5) tsnd_mbf		メッセージバッファへ送信（タイムアウト有）

・psnd_mbf および tsnd_mbf(tmout = TMO_POL) を，タスク独立部ないしはディ
スパッチ禁止状態から実行することができる．

・メッセージは，バッファ中では INT型のデータ 1つ分のサイズさらに，メッ
セージを 1つ送信する度に，管理用のエリアとして，INT型のデータ 1つ分の
エリアがメッセージバッファから取られる．ref_mbf で参照できる空きバッファ
のサイズ（frbufsz）は，これらの分も減少することになる．

・タスクがメッセージ送信待ちの行列を作った場合に，待ち行列の中では後方
にあっても，送信しようとするメッセージサイズが小さく，メッセージバッファ
の残り領域に入るならば，後方のタスクが優先される．そのため，送信待ち行
列は，厳密には FIFO にならない．

(6) rcv_mbf		メッセージバッファから受信
(7) prcv_mbf		メッセージバッファから受信（ポーリング）
(8) trcv_mbf		メッセージバッファから受信（タイムアウト有）

・メッセージバッファからの受信によって，複数のタスクが同時にメッセージ
送信可能となり待ち解除される場合，メッセージバッファ中でのメッセージの
順序および待ち解除後のレディキュー中のタスクの順序については，元のメッ
セージバッファ送信待ち行列中での順序を保存する．

(9) ref_mbf		メッセージバッファ状態参照

・待ちタスクがある場合，wtsk，stsk には待ち行列の先頭のタスクの ID を
返す．

(10) cre_por		ランデブ用のポート生成

・呼出しメッセージの最大長（maxcmsg），返答メッセージの最大長（maxrmsg）
が負または 0 の場合，E_PARエラーになる．

・ItIs では，cre_por をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．

(11) del_por		ランデブ用のポート削除

・ItIs では，del_por をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．

(12) cal_por		ポートに対するランデブの呼出し
(13) pcal_por		ポートに対するランデブの呼出し（ポーリング）
(14) tcal_por		ポートに対するランデブの呼出し（タイムアウト有）

(15) acp_por		ポートに対するランデブ受付け
(16) pacp_por		ポートに対するランデブ受付け（ポーリング）
(17) tacp_por		ポートに対するランデブ受付け（タイムアウト有）

(18) fwd_por		ポートに対するランデブ回送

(19) rpl_rdv		ランデブ返答

・ItIs では，ランデブ応答メッセージの長さを 0 にすることができる．

(20) ref_por		ポート状態参照

・待ちタスクがある場合，wtsk，atsk には待ち行列の先頭のタスクの ID を
返す．

・ItIs では，ref_por をタスク独立部から呼び出すことはできない．呼び出
した場合，E_CTXエラーになる．


3.5. 割込み管理機能

(1) def_int		割込みハンドラ定義

・dintno の意味はターゲットCPU 毎に定める．

・ターゲットシステムによっては，pk_dint = NADR にして，前に定義した割
込みハンドラの定義解除を行う機能はサポートしていない．その場合には， 
pk_dint = NADR で呼び出すと，E_NOSPTエラーとなる．これは，ターゲットシ
ステムによっては，ItIs が ROMモニタに依存して動作するように作られてお
り，どのように戻せばよいかを管理していないためである．

(2) ret_int		割込みハンドラから復帰

・アセンブラで記述された割込みハンドラからは，ソフトウェア割込みで 
ret_int を呼び出す，_i_ret_int をサブルーチンコールする，ないしは 
__ret_int へ分岐することで復帰することができる．

・C言語で記述された割込みハンドラからは，return や関数の最後で自動的に
復帰できるため，C言語から呼び出す ret_int はサポートしない．他のシステ
ムとの互換性のために ret_int が必要になる場合は，以下の定義により代用
できる．

#define ret_int()	{ ruturn; }

(3) ret_wup		割込みハンドラ復帰とタスク起床

・ret_wup は，wup_tsk と ret_int の複合システムコールであり，ItIs では
サポートしていない．他のシステムとの互換性のために ret_wup が必要にな
る場合は，以下の定義により代用できる（C言語の場合）．

#define ret_wup(tskid)	{ wup_tsk(tskid); return; }

(4) loc_cpu		割込みとディスパッチの禁止

(5) unl_cpu		割込みとディスパッチの許可

(6) dis_int		割込み禁止
(7) ena_int		割込み許可

・ItIs の現バージョンでは，これらのシステムコールはサポートしていない．
将来的には，ターゲットCPU 依存にこれらのシステムコールを実装する可能性
はある．

(8) chg_iXX		割込みマスク変更

・chg_iXX の具体的な名称はターゲットCPU 毎に定義される．

・chg_iXX は割込みマスクを指定した値に設定する．指定した値が，ターゲッ
トCPU 毎に定義される割込みマスク値の範囲外の場合，E_PARエラーとなる．
タスク独立部から呼ばれた場合，一般には設定できる割込みマスク値の範囲が
狭くなる．

・設定した割込みマスクの値により，ref_sys で参照できるタスク部のシステ
ム状態（sysstat）が変化する．具体的な対応関係は，ターゲットCPU 毎に定
義される．

(9) ref_iXX		割込みマスク参照

・ref_iXX の具体的な名称はターゲットCPU 毎に定義される．

・ref_iXX は割込みマスクの現在値を読み出すシステムコールである．


3.6. メモリプール管理機能

(1) cre_mpl		可変長メモリプール生成

・可変長メモリプール属性（mplatr）として，待ちタスクの優先度順のキュー
イング（TA_TPRI）をサポートしている．

・可変長メモリプールの管理アルゴリズムとして，first-fit の他に 
half-fit をサポートして可変長メモリプール属性（mplatr）により選択可能
とする計画であるが，現バージョンでは first-fit しかサポートしていない．

・タスクがメモリ獲得待ちの行列を作った場合に，待ち行列の中では後方にあっ
ても，要求ブロックサイズが小さく，メモリプールからすぐにブロックが獲得
できるならば，後方のタスクが優先される（つまり，ITRON2 の TA_CNT に相
当）．そのため，メモリ獲得待ち行列は，厳密には FIFO ないしは優先度順に
はならない．

・メモリプール全体のサイズ（mplsz）は，大きい方に丸められる．丸める単
位は，ポインタ 4つ分のサイズである．

・可変長メモリプールの領域は，cre_mpl 実行時に，システムメモリプールか
ら取られる．取れない場合には，E_NOMEMエラーとなる．

・システム用の mplid = (-4) のメモリプールをサポートしている．システム
用メモリプールを生成，削除することはできないが，メモリブロックの獲得，
返却，メモリプールの状態参照をすることができる（μITRON3.0仕様では，メ
モリプールの状態参照のみできることになっている）．

(2) del_mpl		可変長メモリプール削除

(3) get_blk		可変長メモリブロック獲得
(4) pget_blk		可変長メモリブロック獲得（ポーリング）
(5) tget_blk		可変長メモリブロック獲得（タイムアウト有）

・pget_blk および tget_blk(tmout = TMO_POL) を，タスク独立部ないしはディ
スパッチ禁止状態から実行することができる．

・メモリブロックサイズ（blksz）は，大きい方に丸められる．丸める単位は，
ポインタ 2つ分のサイズである．

・可変長メモリブロックを 1つ獲得する度に，管理用のエリアとして，ポイン
タ 2つ分のエリアがメモリプールから取られる．さらに，残りエリアの管理の
都合で，さらにポインタ 2つ分のエリアが取られる場合もある．ref_mpl で参
照できる空き領域の合計サイズ（frsz）からは，これらの管理エリアの分も減
少することになる．

(6) rel_blk		可変長メモリブロック返却

・メモリブロックの返却によって，複数のタスクが同時にメモリを獲得し待ち
解除される場合，待ち解除後のレディキュー中のタスクの順序については，元
のメモリプール待ち行列中での順序を保存する．

(7) ref_mpl		可変長メモリプール状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．

・ref_mpl は，最大空き領域のサイズを求めるためにメモリプール全体をスキャ
ンする．そのため，実行効率がかなり悪くなるので，デバッグ目的以外には使
わない方がよい．

・システム用メモリプールの状態をユーザタスク（スーパバイザモードで動い
ている場合を除く）から参照することはできない（μITRON3.0仕様では，ユー
ザタスクからも状態参照できることになっている）．

(8) cre_mpf		固定長メモリプール生成

・固定長メモリプール属性として，待ちタスクの優先度順のキューイング 
（TA_TPRI）をサポートしている．

・固定長メモリブロックサイズ（blksz）は，大きい方に丸められる．丸める
単位は，ポインタ 1つ分のサイズである．

・固定長メモリプールの領域は，cre_mpf 実行時に，システムメモリプールか
ら取られる．取れない場合には，E_NOMEMエラーとなる．

(9) del_mpf		固定長メモリプール削除

(10) get_blf		固定長メモリブロック獲得
(11) pget_blf		固定長メモリブロック獲得（ポーリング）
(12) tget_blf		固定長メモリブロック獲得（タイムアウト有）

・pget_blf および tget_blf(tmout = TMO_POL) を，タスク独立部ないしはディ
スパッチ禁止状態から実行することができる．

(13) rel_blf		固定長メモリブロック返却

(14) ref_mpf		固定長メモリプール状態参照

・待ちタスクがある場合，wtsk には待ち行列の先頭のタスクの ID を返す．


3.7. 時間管理機能

(1) set_tim		システムクロック設定

(2) get_tim		システムクロック参照

(3) dly_tsk		タスク遅延

(4) def_cyc		周期起動ハンドラ定義

・cycno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

・ItIs では，周期起動ハンドラは割込みが禁止された状態で起動されるため，
ハンドラ内では最小限の処理のみ行って，残りの処理はタスクに任せるように
作るべきである．

・周期起動ハンドラ属性（cycatr）に TA_HLNG を指定しても，実際には何も
しない．

(5) act_cyc		周期起動ハンドラ活性制御

・cycno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

(6) ref_cyc		周期起動ハンドラ状態参照

・cycno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

(7) def_alm		アラームハンドラ定義

・almno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

・アラームハンドラは，ハンドラ起動の時点（厳密には起動する直前）で，自
動的に定義解除される．

・ItIs では，アラームハンドラは割込みが禁止された状態で起動されるため，
ハンドラ内では最小限の処理のみ行って，残りの処理はタスクに任せるように
作るべきである．

・アラームハンドラ属性（almatr）に TA_HLNG を指定しても，実際には何も
しない．

(8) ref_alm		アラームハンドラ状態参照

・almno としては，1 からシステム構成設定ファイル中で設定した値までが使
える．それ以外の値を指定した時は，E_PARエラーとなる．

(9) ret_tmr		タイマハンドラから復帰

・タイマハンドラからは，アセンブラのリターン命令，C言語の return や関
数の最後で自動的に復帰できるため，ret_tmr はサポートしない．他のシステ
ムとの互換性のために ret_tmr が必要になる場合は，以下の定義により代用
できる（C言語の場合）．

#define ret_tmr()	{ ruturn; }


3.8. システム管理機能

(1) get_ver		バージョン参照

・現バージョンで参照される情報は以下の通り．

	maker	OS製造メーカ		0x0000	実験用システム
	id	OS形式番号		0x5004	（深い意味はない）
	spver	仕様書バージョン番号	0x5302	μITRON，Ver.3.02
	prver	OS製品バージョン番号	0xXYYZ	Release X.YY.Z
	prno	製品管理情報		0....0	（未使用）
	cpu	CPU情報			0xXXXX	CPUコード
	var	バリエーション		0xc000	レベルE

(2) ref_sys		システム状態参照

・準タスク部実行中の場合は，sysstat に TTS_QTSK が返る．また，準タスク
部でディスパッチ禁止中の場合は (TTS_QTSK|TTS_DDSP)，準タスク部で割込み
およびディスパッチ禁止中の場合は (TTS_QTSK|TTS_LOC) が返る（ItIs での
拡張機能）．

・整理すると，sysstat は次のような値をとる．

	TTS_TSK			0
	TTS_TSK|TTS_DDSP	1
	TTS_TSK|TTS_LOC		3
	TTS_QTSK		8
	TTS_QTSK|TTS_DDSP	9
	TTS_QTSK|TTS_LOC	11
	TTS_INDP		4

・runtskid には，現在 RUN状態にあるタスクの ID が返る（RUN状態の定義に
ついては，「ref_tsk」の項を参照）．RUN状態のタスクがない場合には，FALSE 
が返される．

・schedtskid には，実行すべきタスクの ID が返る．実行すべきタスクとは，
スケジューリングの結果 RUN状態にすべきとされたタスクで，遅延ディスパッ
チの原則やディスパッチが禁止されている状態があるために，現在 RUN状態に
なっているタスクと一致するとは限らない．実行可能なタスクがない場合には，
FALSE が返る．

(3) ref_cfg		コンフィグレーション情報参照

・現バージョンでは，参照できる情報はない．

(4) def_svc		拡張SVCハンドラ定義

・s_fncd としては，1 からシステム構成設定ファイル中で設定した値までが
使える．それ以外の値を指定した時は，E_PARエラーとなる．

・pk_dsvc = NADR とした場合には，前に定義した拡張SVCハンドラの定義解除
を行う．既に定義済みの拡張機能コードに対して，拡張SVCハンドラを再定義
することができる．その際に，あらかじめ定義解除しておく必要はない．

・拡張SVCハンドラ属性（svcatr）に TA_HLNG を指定しても，実際には何もし
ない．

(5) def_exc		例外ハンドラ定義

・サポートしない．


3.9. ネットワークサポート機能

・サポートしない．


3.10. ID自動割当機能

(1) vcre_tsk	タスク生成（ID自動割当）		   （機能コード: -241）

【パラメータ】
    T_CTSK*	pk_ctsk		タスク生成情報

【リターンパラメータ】
    ER		ercd		生成したタスクのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_tsk(T_CTSK *pk_ctsk);

【解説】
ID番号を指定せずにタスクを生成し，生成したタスクの ID（必ず正の値）を 
ercd に返す．ercd が負の場合は，エラーコードを表す．割当て可能な ID が
ない場合，EV_FULLエラーとなる．その他については，cre_tsk と同じ．

(2) vcre_sem	セマフォ生成（ID自動割当）		   （機能コード: -242）

【パラメータ】
    T_CSEM*	pk_csem		セマフォ生成情報

【リターンパラメータ】
    ER		ercd		生成したセマフォのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_sem(T_CSEM *pk_csem);

【解説】
ID番号を指定せずにセマフォを生成し，生成したセマフォの ID（必ず正の値）
を ercd に返す．ercd が負の場合は，エラーコードを表す．割当て可能な ID 
がない場合，EV_FULLエラーとなる．その他については，cre_sem と同じ．

(3) vcre_flg	イベントフラグ生成（ID自動割当）	   （機能コード: -243）

【パラメータ】
    T_CFLG*	pk_cflg		イベントフラグ生成情報

【リターンパラメータ】
    ER		ercd		生成したイベントフラグのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_flg(T_CFLG *pk_cflg);

【解説】
ID番号を指定せずにイベントフラグを生成し，生成したイベントフラグの ID
(必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを表す．割
り当て可能な ID がない場合，EV_FULLエラーとなる．その他については，
cre_flg と同じ．

(4) vcre_mbx	メイルボックス生成（ID自動割当）	   （機能コード: -244）

【パラメータ】
    T_CMBX*	pk_cmbx		メイルボックス生成情報

【リターンパラメータ】
    ER		ercd		生成したメイルボックスのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_mbx(T_CMBX *pk_cmbx);

【解説】
ID番号を指定せずにメイルボックスを生成し，生成したメイルボックスの ID
(必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを表す．割
り当て可能な ID がない場合，EV_FULLエラーとなる．その他については，
cre_mbx と同じ．

(5) vcre_mbf	メッセージバッファ生成（ID自動割当）	   （機能コード: -245）

【パラメータ】
    T_CMBF*	pk_cmbf		メッセージバッファ生成情報

【リターンパラメータ】
    ER		ercd		生成したメッセージバッファのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_mbf(T_CMBF *pk_cmbf);

【解説】
ID番号を指定せずにメッセージバッファを生成し，生成したメッセージバッファ
の ID（必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを表
す．割当て可能な ID がない場合，EV_FULLエラーとなる．その他については，
cre_mbf と同じ．

(6) vcre_por	ランデブ用のポート生成（ID自動割当）	   （機能コード: -246）

【パラメータ】
    T_CPOR*	pk_cpor		ランデブ用ポート生成情報

【リターンパラメータ】
    ER		ercd		生成したランデブ用ポートのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_por(T_CPOR *pk_cpor);

【解説】
ID番号を指定せずにランデブ用ポートを生成し，生成したランデブ用ポートの 
ID（必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを表す．
割当て可能な ID がない場合，EV_FULLエラーとなる．その他については， 
cre_por と同じ．

(7) vcre_mpl	可変長メモリプール生成（ID自動割当）	   （機能コード: -247）

【パラメータ】
    T_CMPL*	pk_cmpl		可変長メモリプール生成情報

【リターンパラメータ】
    ER		ercd		生成した可変長メモリプールのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_mpl(T_CMPL *pk_cmpl);

【解説】
ID番号を指定せずに可変長メモリプールを生成し，生成した可変長メモリプー
ルの ID（必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを
表す．割当て可能な ID がない場合，EV_FULLエラーとなる．その他について
は，cre_mpl と同じ．

(8) vcre_mpf	固定長メモリプール生成（ID自動割当）	   （機能コード: -248）

【パラメータ】
    T_CMPF*	pk_cmpf		固定長メモリプール生成情報

【リターンパラメータ】
    ER		ercd		生成した固定長メモリプールのID，エラーコード

【C言語インタフェース】
    ER ercd =vcre_mpf(T_CMPF *pk_cmpf);

【解説】
ID番号を指定せずに固定長メモリプールを生成し，生成した固定長メモリプー
ルの ID（必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを
表す．割当て可能な ID がない場合，EV_FULLエラーとなる．その他について
は，cre_mpf と同じ．

(9) vdef_cyc	周期起動ハンドラ定義（ID自動割当）	   （機能コード: -255）

【パラメータ】
    T_DCYC*	pk_dcyc		周期起動ハンドラ定義情報

【リターンパラメータ】
    ER		ercd		定義した周期起動ハンドラの番号，エラーコード

【C言語インタフェース】
    ER ercd =vdef_cyc(T_DCYC *pk_dcyc);

【解説】
番号を指定せずに周期起動ハンドラを定義し，定義した周期起動ハンドラの 
番号（必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを表
す．割当て可能な番号がない場合，EV_FULLエラーとなる．また，pk_dcyc =
NADR として，周期起動ハンドラの定義解除を行う機能はない．その他につい
ては，def_cyc と同じ．

(10) vdef_alm	アラームハンドラ定義（ID自動割当）	   （機能コード: -256）

【パラメータ】
    T_DALM*	pk_dalm		アラームハンドラ定義情報

【リターンパラメータ】
    ER		ercd		定義したアラームハンドラの番号，エラーコード

【C言語インタフェース】
    ER ercd =vdef_alm(T_DALM *pk_dalm);

【解説】
番号を指定せずにアラームハンドラを定義し，定義したアラームハンドラの 
番号（必ず正の値）を ercd に返す．ercd が負の場合は，エラーコードを表
す．割当て可能な番号がない場合，EV_FULLエラーとなる．また，pk_dalm =
NADR として，アラームハンドラの定義解除を行う機能はない．その他につい
ては，def_alm と同じ．


3.11. デバッグサポート機能

(1) vset_reg	タスクのレジスタ内容設定		   （機能コード: -225）

    vset_reg: Set Task Registers

【パラメータ】
    ID		tskid		タスクID
    T_REGS*	pk_regs		汎用レジスタの値を入れるパケット
    T_EIT*	pk_eit		プログラムカウンタなどの値を入れるパケット
    T_CREGS*	pk_cregs	制御レジスタの値を入れるパケット

  pk_regs，pk_eit，pk_cregs の内容
    ターゲットCPU 毎に定める

【リターンパラメータ】
    ER		ercd		エラーコード

【C言語インタフェース】
    ER ercd =vset_reg(ID tskid, T_REGS *pk_regs, T_EIT *pk_eit,
		      T_CREGS *pk_cregs);

【解説】
tskid で示されるタスクの，TCB の中およびシステムスタック上に置かれてい
るレジスタの内容を設定する．ただし ItIs では，システムコール実行中にも
タスク切替えが起こるため，設定するレジスタの値が，タスク部実行中の値で
あるとは限らない．

このシステムコールにより，コンテキストに依存したすべてのレジスタの値を
設定することができる．pk_regs により汎用レジスタ値，pk_eit によりプロ
グラムカウンタなどの値，pk_cregs により各種の制御レジスタの値を設定す
ることができる．pk_regs，pk_eit あるいは pk_cregs の値を NADR とするこ
とにより，対応するレジスタの設定は行われない．

DORMANT状態のタスクに対してこのシステムコールを発行し，タスク起動直後
のレジスタの値を設定することができる．ただし，sta_tsk によりタスク起動
コード（stacd）およびタスク拡張情報がレジスタに渡される場合には，この
システムコールで値を設定しても，それらのレジスタは sta_tsk により上書
きされてしまう．また，スタックポインタの値も sta_tsk で変更される場合
がある．

このシステムコールを自タスクに対して用いることはできない（E_OBJエラー
になる）．また，タスク独立部から呼び出すこともできない（E_CTXエラーにな
る）．

【エラーコード（ercd）】
    E_OK	正常終了
    E_ID	不正ID番号（tskidが不正あるいは利用できない）
    E_NOEXS	オブジェクトが存在していない（tskid のタスクが存在しない）
    E_OACV	オブジェクトアクセス権違反
    E_OBJ	オブジェクトの状態が不正（対象タスクが自タスク）
    E_PAR	パラメータエラー（レジスタの値が不正）
    E_CTX	コンテキストエラー（タスク独立部からの発行）

(2) vget_reg	タスクのレジスタ内容参照		   （機能コード: -226）

    vget_reg: Get Task Registers

【パラメータ】
    ID		tskid		タスクID
    T_REGS*	pk_regs		汎用レジスタの値を入れるパケット
    T_EIT*	pk_eit		プログラムカウンタなどの値を入れるパケット
    T_CREGS*	pk_cregs	制御レジスタの値を入れるパケット

【リターンパラメータ】
    ER		ercd		エラーコード   

  pk_regs，pk_eit，pk_cregs の内容
    ターゲットCPU 毎に定める

【C言語インタフェース】
    ER ercd =vget_reg(T_REGS *pk_regs, T_EIT *pk_eit, T_CREGS *pk_cregs,
		      ID tskid);

【解説】
tskid で示されるタスクの，TCB の中およびシステムスタック上に置かれてい
るレジスタの内容を参照する．ただし ItIs では，システムコール実行中にも
タスク切替えが起こるため，参照するレジスタの値が，タスク部実行中の値で
あるとは限らない．

このシステムコールにより，コンテキストに依存したすべてのレジスタの値を
参照することができる．pk_regs により汎用レジスタ値，pk_eit によりプロ
グラムカウンタなどの値，pk_cregs により各種の制御レジスタの値を参照す
ることができる．pk_regs，pk_eit あるいは pk_cregs の値を NADR とするこ
とにより，対応するレジスタの参照は行われない．

このシステムコールを自タスクに対して用いることはできない（E_OBJエラー
になる）．また，タスク独立部から呼び出すこともできない（E_CTXエラーにな
る）．

【エラーコード（ercd）】
    E_OK	正常終了
    E_ID	不正ID番号（tskid が不正あるいは利用できない）
    E_NOEXS	オブジェクトが存在していない（tskid のタスクが存在しない）
    E_OACV	オブジェクトアクセス権違反
    E_OBJ	オブジェクトの状態が不正（対象タスクが自タスク）
    E_CTX	コンテキストエラー（タスク独立部からの発行）


3.12. 性能評価用システム時刻参照機能

(1) vget_tim	性能評価用システム時刻参照		   （機能コード: -82）

    vget_tim: Get Time for Performance Evaluation

【パラメータ】
    SYSUTIME*	pk_utim		現在の性能評価用システム時刻を返すパケット

【リターンパラメータ】
    ER		ercd		エラーコード

  pk_utim の内容
    SYSUTIME    sysutim		現在の性能評価用システム時刻

【C言語インタフェース】
    ER ercd =vget_tim(SYSUTIME *pk_utim);

【解説】
現在の性能評価用システム時刻を読み出し，sysutim に返す．

性能評価用システム時刻は 1μ秒単位で返されるが，実際にどれだけの精度が
あるかは，ターゲットシステムに依存する．

【エラーコード（ercd）】
    E_OK	正常終了


3.13. 優先度継承セマフォ機能

優先度継承セマフォ機能をサポートするシステムコールは，以下の 8つである．
それぞれについての詳細については，「優先度継承セマフォ機能の仕様」を参
照のこと．

(1) vcre_pis	優先度継承セマフォ生成			   （機能コード: -257）
(2) vvcre_pis	優先度継承セマフォ生成（ID自動割当）		       （-259）
(3) vdel_pis	優先度継承セマフォ削除				       （-258）
(4) vsig_pis	優先度継承セマフォ資源返却			       （-264）
(5) vwai_pis	優先度継承セマフォ資源獲得			       （-261）
(6) vpreq_pis	優先度継承セマフォ資源獲得（ポーリング）	       （-262）
(7) vtwai_pis	優先度継承セマフォ資源獲得（タイムアウト有）	       （-263）
(8) vref_pis	優先度継承セマフォ状態参照			       （-260）


3.14. タスク付属メイルボックス機能

(1) vsnd_tmb	タスク付属メイルボックスへ送信		   （機能コード: -272）

    vsnd_tmb: Send Message to Task Mailbox

【パラメータ】
    ID		tskid		タスクID
    T_MSG*	pk_msg		メッセージパケットの先頭アドレス

【リターンパラメータ】
    ER		ercd		エラーコード

【C言語インタフェース】
    ER ercd =vsnd_tmb(ID tskid, T_MSG *pk_msg);

【解説】
tskid で示されたタスクに付属するメイルボックスに，pk_msg を先頭アドレ
スとするメッセージパケットを送信する．メッセージパケットの内容はコピー
されず，受信時には先頭アドレスのみが渡される．

対象タスクがタスク付属メイルボックスからの受信を待っていた場合には，対
象タスクの待ち状態が解除され，vsnd_tmb で指定した pk_msg がそのタスク
に送信されて，vrcv_tmb のリターンパラメータとなる．一方，対象タスクが
受信待ち状態でなければ，送信されたメッセージは，メイルボックス中のメッ
セージキューに入れられる．どちらの場合にも，tsnd_tmb 発行タスクは待ち
状態とはならない．

【補足説明】
pk_msg は，メッセージヘッダを含めたメッセージパケットの先頭アドレスで
ある．メッセージパケットの形式は，通常のメイルボックスと同一である．

【エラーコード（ercd）】
    E_OK	正常終了
    E_ID	不正ID番号（tskid が不正あるいは利用できない）
    E_NOEXS	オブジェクトが存在していない（tskid のタスク存在しない）
    E_OACV	オブジェクトアクセス権違反（システムオブジェクトをアク
		セスする権利を持たない環境からの発行で tskid < (-4)）
    E_OBJ	オブジェクトの状態が不正（対象タスクが自タスクまたは 
		DORMANT状態）

(2) vrcv_tmb	タスク付属メイルボックスから受信	   （機能コード: -269）
(3) vprcv_tmb	タスク付属メイルボックスから受信（ポーリング）	       （-270）
(4) vtrcv_tmb	タスク付属メイルボックスから受信（タイムアウト有）     （-271）

    vrcv_tmb:	Receive Message from Task Mailbox
    vprcv_tmb:	Poll and Receive Message from Task Mailbox
    vtrcv_tmb:	Receive Message from Task Mailbox with Timeout

【パラメータ（vrcv_tmb，vprcv_tmb の場合）】
    なし

【パラメータ（vtrcv_tmb の場合）】
    TMO		tmout		タイムアウト指定

【リターンパラメータ】
    ER		ercd		エラーコード
    T_MSG*	pk_msg		メッセージパケットの先頭アドレス

【C言語インタフェース】
    ER ercd = vwai_pis(T_MSG **ppk_msg);
    ER ercd =vpreq_pis(T_MSG **ppk_msg);
    ER ercd =vtrcv_tmb(T_MSG **ppk_msg, TMO tmout);

【解説】
vrcv_tmb では，それを呼び出したタスクに付属するメイルボックスからメッ
セージを受信する．付属するメイルボックスにまだメッセージが送信されてい
ない場合には，本システムコールを発行したタスクは待ち状態となり，メッセー
ジの到着を待つ．一方，付属するメイルボックスに既にメッセージが入ってい
る場合には，メッセージキューの先頭にあるメッセージを 1つ取り出して，そ
れをリターンパラメータ pk_msg とする．

vprcv_tmb は，vrcv_tmb から待ち状態に入る機能を取り除いたシステムコー
ルであり，vrcv_tmb を実行した場合に待ち状態に入るかどうかのポーリング
を行う．vprcv_tmb システムコールのパラメータの意味は vrcv_tmb と同じで
ある．

vtrcv_tmb は，vrcv_tmb にタイムアウトの機能を付け加えたシステムコール
であり，tmout により待ち時間の最大値（タイムアウト値）を指定することが
できる．タイムアウト指定が行われた場合，待ち解除の条件が満足されない 
（メッセージが到着しない）まま tmout の時間が経過すると，タイムアウト
エラー E_TMOUT となってシステムコールが終了する．tmout の指定方法は，
他のシステムコールと同様である．

【補足説明】
pk_msg は，メッセージヘッダを含めたメッセージパケットの先頭アドレスで
ある．メッセージパケットの形式は，通常のメイルボックスと同一である．

【エラーコード（ercd）】
    E_OK	正常終了
    E_PAR	パラメータエラー（tmout <= (-2)）
    E_RLWAI	待ち状態強制解除（待ちの間に rel_wai を受け付け）
    E_TMOUT	ポーリング失敗またはタイムアウト
    E_CTX	コンテキストエラー（タスク独立部またはディスパッチ禁止
		状態で実行）

(5) vref_tmb	タスク付属メイルボックス状態参照	   （機能コード: -268）

    vref_tmb:	Refer Task Mailbox Status

【パラメータ】
    ID		tskid		タスクID
    T_RTMB*	pk_rtmb		メイルボックス状態を返すパケットアドレス

【リターンパラメータ】
    ER		ercd		エラーコード

  pk_rpis の内容
    BOOL_ID	wtsk		タスクの待ちの有無
    T_MSG*	pk_msg		次に受信されるメッセージパケットの先頭アドレス

【C言語インタフェース】
    ER ercd =vref_tmb(T_RTMB *pk_rtmb, ID tskid);

【解説】
tskid で示されたタスクに付属するメイルボックスの各種の状態を参照し，リ
ターンパラメータとして次に受信されるメッセージ，タスクの待ちの有無を返
す．

wtsk は，tskid で示されたタスクが付属するメイルボックスで待っているか
どうかを示す．待っていない場合は wtsk = FALSE = 0 となる．待ちタスクが
ある場合は，wtsk としてタスクの ID を返す．

pk_msg は，次に vrcv_tmb を実行した場合に受信されるメッセージである．
メッセージキューにメッセージが無い時は，pk_msg = NADR = (-1) となる．
また，どんな場合でも，pk_msg = NADR と wtsk = FALSE の少なくとも一方は
成り立つ．

【補足説明】
vref_tmb と vprcv_tmb は，いずれも待ち状態に入ることなく次のメッセージ
を知るシステムコールである．しかし，vref_tmb が単に次のメッセージを参
照するシステムコールであるのに対して，vprcv_tmb の場合はメッセージがあ
る時に vrcv_tmb と同様の動作をする（メッセージを取り出してメッセージキュー
から削除する）という点が異なっている．

【エラーコード（ercd）】
    E_OK	正常終了
    E_ID	不正ID番号（tskid が不正あるいは利用できない）
    E_NOEXS	オブジェクトが存在していない（tskid のタスク存在しない）
    E_OACV	オブジェクトアクセス権違反（システムオブジェクトをアク
		セスする権利を持たない環境からの発行で tskid < (-4)）
    E_OBJ	オブジェクトの状態が不正（対象タスクが DORMANT状態）


４．システムタスクと標準の拡張SVC

この節では，ItIs が標準で動作させるシステムタスクおよびドライバと，そ
れらを利用するための拡張SVC について説明する．

この節の内容は，暫定的な仕様であり，今後大幅に変更される可能性がある．
特に，シリアルインタフェースドライバについては，仕様も含めて，完成度が
低いと考えている．


4.1. 初期化タスク

初期化タスクは最初に動作して，必要な初期化を行うためのタスクである．必
要な初期化を行うと，slp_tsk により待ち状態に入る．システム全体を安全に
停止させる場合には，初期化タスクを wup_tsk で起床させればよい．なお，
初期化タスクは最高優先度で動作する．

現バージョンでは，以下の初期化を行う．

 (a) シリアルインタフェースドライバを起動する．
 (b) システムログタスクを起動する．
 (c) 初期起動タスクを起動する．


4.2. シリアルインタフェースドライバ

シリアルインタフェースドライバは，シリアルI/Oポートを扱うためのドライ
バである．拡張SVCハンドラおよび割込みハンドラで構成される．

標準Cライブラリの低レベル入出力ルーチンを，シリアルインタフェースドラ
イバを呼び出すものにすることで，タスクの標準入出力をシリアルインタフェー
スドライバ経由に切替えることができる．具体的な方法は，用いる標準Cライ
ブラリに依存するため，ターゲットCPU 毎に説明する．

シリアルインタフェースドライバを呼び出す拡張SVC の仕様は以下の通りであ
る．なお，これらの拡張SVC を，タスク独立部から呼び出すことはできない．
呼び出した場合には，E_CTXエラーとなる．

(1) ER_INT serial_read(int portid, char *buffer, unsigned int len)

portid で示されるシリアルポートから，lenバイトの文字列を読み込み，
buffer からの領域に入れる．実際に読み込んだ文字数を返す（正または 0）．
portid に 0 を指定すると，コンソールとして用いているシリアルポートを指
定したことになる．

(2) ER_INT serial_write(int portid, char *buffer, unsigned int len)

portid で示されるシリアルポートに，buffer からの lenバイトの文字列を書
き出す．実際に書き出した文字数を返す（正または 0）．portid に 0 を指定
すると，コンソールとして用いているシリアルポートを指定したことになる．

(3) ER_INT serial_ioctl(int portid, int req, int arg)

portid で示されるシリアルポートの制御情報を設定/解除する．portid に 0 
を指定すると，コンソールとして用いているシリアルポートを指定したことに
なる．

設定/解除できる制御情報は，

・エコーバックモード（ECHO）

    TRUE … エコーバックを行う
    FALSE … エコーバックを行わない

・入力モード（INPUT）

    RAW … serial_read で，長さの指定にかかわらず 1文字のみ読み込む．
    CANONICAL … serial_read で，改行コードが来るか，指定した長さまで
		 読み込む．

・改行モード（NEWLINE）

    TRUE … LF（line feed）を CR（carriage return）+ LF に変換して出力する．
    FALSE … 上の変換を行わない．

・フロー制御モード（FLOWC）

    IXON … 送信側に対して，XON/XOFF によるフロー制御を行う．
    IXANY … 送信側に対して XON/XOFF によるフロー制御を行っている時に，
	     任意の文字で，停止状態を解除する．
    IXOFF … 受信側に対して，XON/XOFF によるフロー制御を行う．

req に設定するモードの種類（ECHO/INPUT/NEWLINE/FLOWC），arg に設定する
値を入れて呼び出すと，制御情報が設定される．モードの種類と GETCTL の論
理和を req に入れて呼び出すと，制御情報の現在値を，戻り値として取り出
すことができる．後者の場合，arg の値は無視される．

例1. シリアルポート1 のフロー制御を止める．

ercd = serial_ioctl(1, FLOWC, 0);

例2. コンソール用ポートの入力モードを取り出す．

mode = serial_ioctl(0, INPUT|GETCTL, 0);

serial_ioctl で用いる定数は，itis_ioctl.h 中で定義されている．

(4) ER serial_init(int portid)

portid で示されるシリアルポートを初期化する．

(5) ER serial_shutdown(int portid, int flush)

portid で示されるシリアルポートのシャットダウン処理をする．flush が 0 
以外の場合は，送信バッファの内容が空になるまでループで待つ．


4.3. システムログタスク

システムログタスクは，システムログ用メッセージバッファからメッセージを
取り出し，シリアルポートへ書き出す．メッセージを 1つ出力する毎に，改行
を行う．

システムログ用のメッセージバッファにアクセスできないタスクのために，シ
ステムログ用のメッセージバッファに文字列を送信するための拡張SVC を用意
している．また，この拡張SVC は，ログタスクが動作していない時に，システ
ムの低レベル文字出力ルーチンを使って，メッセージを出力する．拡張SVC の
仕様は以下の通りである．

(1) ER syslog_send(const char *string, int len)

string から lenバイトの文字列をシステムログとして書き出す．


4.4. 初期起動タスク

初期起動タスクは，最初に起動されるアプリケーションタスクである．カーネ
ルをインタラクティブに使う場合は，シェルないしはコマンドインタプリタが
初期起動タスクになる．

ItIs の現バージョンでは，xscheme を ITRON の主なシステムコールを呼び出
せるように拡張して，シェルの代わりに使っている．システムコールを呼び出
すために，システムコールと同じ名前の関数を用意している．関数へ渡す引数
は，システムコールインタフェースに準じて決めている（詳細は省略）．

xscheme を動作させるためには，標準Cライブラリが必要である．また， 
xscheme は標準では浮動少数点演算をサポートしているが，現バージョンのカ
ーネルでは FPU をサポートしていないため，コンパイル時に -DNO_FLOAT を
定義して，浮動少数点演算を使う機能を外している．浮動少数点演算を使いた
い場合には -DO_FLOAT を外してコンパイルすることになるが，FPU の有無に
関連して次の2つの方法がある．

(1) ソフトウェアによる浮動小数点演算パッケージを用いる．

(2) FPU を持つターゲットCPU の場合，xscheme をコンパイル時に 
-msoft-float を外すことで，xscheme から FPU を用いることができる．この
場合，FPU を使うことのできるタスクは 1つのみに限られるため，xscheme 以
外のタスクは FPU を使ってはならないことになる．また，標準ライブラリも 
FPU に対応したものを用いる必要がある．

xscheme はサイズが大きく，また実行効率もそれほど良くはないので，将来的
には別のものに交換する可能性が高い．


５．ItIs タスクサポートライブラリ

ItIs タスクサポートライブラリとして，以下の関数を用意している．この内
のいくつかは，システムタスクからも使われて，カーネルと一緒にリンクされ
る．

    void perror(char *prompt, ER ercd)
    void panic(char *prompt, ER ercd)
    void itis_perror(char *file, int line, char *expr, ER ercd)
    void itis_panic(char *file, int line, char *expr, ER ercd)
    char *itron_strerror(ER ercd)
    void __assert_fail(char *expr, char *file, int line, char *func)
    void syslog(int priority, char *format, ...)
    int setlogmask(int maskpri)
    INT sysstat()

これらのライブラリの仕様は暫定的なものであり，将来的には変更される可能
性が高い．


６．開発環境・インストール・移植

6.1. ディレクトリ・ファイル構成

ディレクトリ構成は次の通り．

    include/	共通ヘッダファイル
	m68k/	    68040依存ヘッダファイル
	tron/	    TRON仕様チップ依存ヘッダファイル
	bsd/	    BSD UNIX シミュレーション環境依存ヘッダファイル
    kernel/	カーネルソースファイル
    systask/	システムタスクソースファイル
    libitis/	ItIsタスクサポートライブラリ
    m68k/	68040依存ファイル
	dve68k/	    DVE-68K/40依存ファイル
	startup/    スタートアップモジュール
    tron/	TRON仕様チップ依存ファイル
	h32/	    Gmicro SBCシステム依存ファイル
	tvme/	    TVME-150依存ファイル
	mcube/	    MCUBE依存ファイル
	startup/    スタートアップモジュール（標準Cライブラリの一部）
    bsd/	BSD UNIX シミュレーション環境依存ファイル
	sunos4/	    SunOS 4.X依存ファイル
    sample/	設定サンプル（Makefile，システム構成設定ファイル）
    utils/	ユーティリティ
    doc/	ドキュメント

各ファイルの概要は次の通り．

    README		リリースメモ
    MINIFEST		配布ファイルの一覧
    ChangeLog		ItIs の変更履歴

    include/
	Makefile		ヘッダファイルインストール用 Makefile
	itron.h			ITRON の標準的な定義
	itron_errno.h		ITRON のエラーコードの定義
	itron_fncode.h		ITRON の機能コードの定義（by genisyscall）
	itis_services.h		ItIsタスク用 標準インクルードファイル
	itis_isyscall.h		システムコールインタフェース（by genisyscall）
	itis_stddefs.h		ItIs で用いる共通的な定義
	itis_syslog.h		syslog ライブラリ用ヘッダファイル
	itis_debug.h		デバックサポート機能のための定義
	itis_ioctl.h		シリアルドライバの ioctl のための定義
	svc_fncode.h		拡張SVC の機能コードの定義
	svc_serial.h		シリアルドライバの拡張SVCインタフェース
	svc_syslog.h		システムログ送信の拡張SVCインタフェース
	bsd_sigio.h		BSD UNIX用 ノンブロッキングI/O サポート

    include/tron/
	itis_scint.h		システムコール起動のための定義

    include/bsd/
	itis_scint.h		システムコール起動のための定義

    kernel/
	itable.S	システムコールディスパッチテーブル（by genisyscall）
	ptable.S	パラメータ処理ディスパッチテーブル（by genisyscall）
	isyscall.h	システムコールのプロトタイプ宣言（by genisyscall）
	isysconf.h	システム構成のデフォルト値の定義
	itis_kernel.h	ItIsカーネル用 標準インクルードファイル
	check.h		各種のエラーチェック用マクロ
	queue.h		ダブルリンクキューの構造・操作の定義
	ready_queue.h	レディキューの構造・操作の定義
	timer.h		タイマ操作ルーチンの定義
	winfo.h		同期・通信オブジェクト毎に必要な待ち情報の定義
	task.h		タスク操作ルーチンの定義
	wait.h		タスク間同期・通信オブジェクト汎用ルーチンの定義
	patchlevel.h	リリース番号，パッチレベルの定義
	startup.c	システムスタートアップルーチン
	task_manage.c	タスク管理機能
	task_sync.c	タスク付属同期機能
	taskmbox.c	タスク付属メイルボックス機能
	semaphore.c	セマフォ機能
	eventflag.c	イベントフラグ機能
	mailbox.c	メイルボックス機能
	messagebuf.c	メッセージバッファ機能
	rendezvous.c	ランデブ機能
	prisem.c	優先度継承セマフォ機能
	mempool.c	可変長メモリプール管理機能
	mempfix.c	固定長メモリプール管理機能
	time_calls.c	時間管理機能
	misc_calls.c	その他のシステムコール
	debug_calls.c	デバッグサポート機能
	task.c		タスク操作ルーチン
	wait.c		待ち状態操作ルーチン
	timer.c		タイマ操作ルーチン
	isyslog.c	カーネル用 システムログ送信ライブラリ
	vsprintf.c	簡易 vsprintf関数
	syscall.def	システムコール定義ファイル
	genisyscall	システムコール定義生成プログラム
	genconfig	システム構成定義ファイル 生成プログラム
	newversion	version.c 生成プログラム

    systask/
	systask.h	システムタスク用 標準インクルードファイル
	inittask.c	初期化タスク
	serial.c	シリアルインタフェースドライバ
	logtask.c	システムログタスク
	sysio.c		カーネルと一緒にリンクするタスク用の入出力ルーチン
	bsd_sigio.c	BSD UNIX用 ノンブロッキングI/O サポートモジュール
	bsd_serial.c	BSD UNIX用 疑似シリアルドライバ

    libitis/
	Makefile	libitis 生成用 Makefile
	perror.c	perror 関数
	panic.c		panic 関数
	itis_perror.c	itis_perror 関数
	itis_panic.c	itis_panic 関数
	strerror.c	itron_strerror 関数
	assert_fail.c	__assert_fail 関数
	syslog.c	syslog 関数
	setlogmask.c	setlogmask 関数
	sysstat.c	sysstat 関数
	glue_newlib.c	newlib 対応の低レベル入出力ルーチン
	bsd_nbio.c	BSD UNIX用 ノンブロッキングI/Oライブラリ
	bsd_nbeio.c	BSD UNIX用 ノンブロッキングI/Oライブラリ（errno 有）

    m68k/
	Makefile.config	Makefile の共通定義
	cpu_conf.h	68040用 構成記述ファイル
	cpu_status.h	システム状態判別/設定マクロ等の定義
	cpu_task.h	CPU に依存するタスク関連処理
	cpu_calls.c	CPU に依存するシステムコール
	cpu_util.c	CPU に依存するその他の関数
	cpu_support.S	CPU に依存するその他のルーチン
	makeoffset.c	offset.h 生成サポートプログラム
	m68k_insn.h	低レベルの CPU操作ルーチン

    m68k/dve68k/
	sys_conf.h	DVE-68K/40 CPUボード用 構成記述ファイル
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン
	sys_timer.h	DVE-68K/40 CPUボード用 タイマ操作ルーチン
	sys_serial.h	DVE-68K/40 CPUボード用 シリアルI/O 操作ルーチン
	dve68k.h	DVE-68K/40 CPUボード ハードウェア定義

    m68k/startup/
	Makefile	スタートアップモジュール生成用 Makefile
	start.S		スタートアップモジュール（crt0.o のソース）

    tron/
	Makefile.config	Makefile の共通定義
	cpu_conf.h	TRON仕様チップ用 構成記述ファイル
	cpu_status.h	システム状態判別/設定マクロ等の定義
	cpu_task.h	CPU に依存するタスク関連処理
	cpu_calls.c	CPU に依存するシステムコール
	cpu_util.c	CPU に依存するその他の関数
	cpu_support.S	CPU に依存するその他のルーチン
	dispatch.S	タスクディスパッチャ
	nd_dispatch.S	タスクディスパッチャ（遅延割込みを使わないバージョン）
	makeoffset.c	offset.h 生成サポートプログラム
	tron_defs.h	TRON仕様チップ依存の定数の定義
	tron_insn.h	低レベルの CPU操作ルーチン

    tron/h32/
	sys_conf.h	Gmicro SBCシステム用 構成記述ファイル
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン
	sys_timer.h	Gmicro SBCシステム用 タイマ操作ルーチン
	sys_serial.h	Gmicro SBCシステム用 シリアルI/O 操作ルーチン
	h32sbc.h	Gmicro SBCシステム ハードウェア定義

    tron/tvme/
	sys_conf.h	TVME-150 CPUボード用 構成記述ファイル
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン
	sys_timer.h	TVME-150 CPUボード用 タイマ操作ルーチン
	sys_serial.h	TVME-150 CPUボード用 シリアルI/O 操作ルーチン
	tvme150.h	TVME-150 CPUボード ハードウェア定義

    tron/mcube/
	sys_conf.h	MCUBE用 構成記述ファイル
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン
	sys_timer.h	MCUBE用 タイマ操作ルーチン
	sys_serial.h	MCUBE用 シリアルI/O 操作ルーチン
	mcube.h		MCUBE ハードウェア定義

    tron/startup/
	Makefile	スタートアップモジュール生成用 Makefile
	start.S		スタートアップモジュール（crt0.o のソース）

    bsd/
	Makefile.config	Makefile の共通定義
	cpu_conf.h	BSD UNIX用 構成記述ファイル
	cpu_status.h	システム状態判別/設定マクロ等の定義
	cpu_task.h	CPU に依存するタスク関連処理
	cpu_calls.c	CPU に依存するシステムコール
	cpu_util.c	CPU に依存するその他の関数
	cpu_support.S	CPU に依存するその他のルーチン（空ファイル）
	makeoffset.c	offset.h 生成サポートプログラム（空ファイル）
	sys_util.c	システムに依存するその他の関数
	sys_support.S	システムに依存するその他のルーチン（空ファイル）
	sys_timer.h	Gmicro SBCシステム用 タイマ操作ルーチン

    bsd/sunos4/
	sys_conf.h	SunOS 4.X用 構成記述ファイル

    bsd/freebsd/
	sys_conf.h	FreeBSD用 構成記述ファイル

    sample/
	Makefile.dve68k	カーネルの Makefile のサンプル（DVE-68K/40 用）
	Makefile.tvme	カーネルの Makefile のサンプル（TVME-150 CPUボード用）
	Makefile.h32	カーネルの Makefile のサンプル（Gmicro SBCシステム用）
	Makefile.mcube	カーネルの Makefile のサンプル（MCUBE用）
	Makefile.sunos4	カーネルの Makefile のサンプル（SunOS 4.X用）
	config.def	システム構成設定ファイルのサンプル
	config.def.bsd	システム構成設定ファイルのサンプル（BSD UNIX用）
	sample1.c	サンプルプログラム

    utils/
	deldep		依存関係定義の削除
	extidata	オブジェクトファイルからデータセクションを抽出
	makedep		依存関係定義の生成
	genoffset	offset.h 生成プログラム

    doc/
	USER		ユーザズマニュアル
	M68K		68040に依存する機能
	TRON		TRON仕様チップに依存する機能
	BSDUNIX		BSD UNIX 上での動作環境
	PRISEM		優先度継承セマフォ機能の仕様
	CONDITION	ItIs の配付・使用条件に関する FAQ


6.2. 開発環境

カーネルをインストールするには，ItIs の標準リリースに含まれる以外に，
以下のツール，ライブラリが必要である．

    GNU開発環境
	GCC（動作確認バージョンはターゲットCPU によって異なる）
	BINUTILS（動作確認バージョンはターゲットCPU によって異なる）
    標準Cライブラリ（用いるライブラリはターゲットCPU によって異なる）
    perl 4（動作確認は 4.036）
    GNU Make（動作確認は 3.75）
    aout2（a.out から Sフォーマット/バイナリ形式への変換ツール）

標準Cライブラリは，標準Cライブラリを使用するタスクを動作させない場合に
は必要ない．その場合の注意については，「標準Cライブラリとスタートアッ
プモジュール」の項を参照すること．

aout2 は，a.outフォーマットをモトローラの Sフォーマットないしはバイナ
リ形式に変換するツールである．a.outフォーマットのファイルが直接ダウン
ロードできる場合には必要ない．


6.3. インストール

標準的なインストール手順は以下の通りである．

最初に，ItIs を展開したディレクトリに，オブジェクトファイルを置くため
のディレクトリを作る（ディレクトリ名は何でもよい）．

    % mkdir OBJ
    % cd OBJ

sample ディレクトリから，適当な Makefile と config.def をコピーし，内
容を作りたいカーネル用に編集する．

    % cp ../sample/Makefile.XXX Makefile
    % cp ../sample/config.def .
    % emacs Makefile config.def

Makefile の依存関係定義部を作ってから，オブジェクトを作る．

    % gmake depend
    % gmake


6.4. ヘッダファイルと ItIs タスクサポートライブラリのインストール

include ディレクトリには，ItIs のカーネルとタスクで共通に用いるヘッダ
ファイルが含まれている．これを，標準的なパスにインストールするには，
include/Makefile 中の CPU の定義を編集し，以下のコマンドを実行する．

    % cd include
    % gmake install

また，libitis ディレクトリには，ItIs タスクサポートライブラリが含まれ
ている．これをコンパイルし，標準的なパスにインストールするには，
libitis/Makefile 中の CPU の定義を編集し，以下のコマンドを実行する．

    % cd libitis
    % gmake
    % gmake install


6.5. 標準Cライブラリとスタートアップモジュール

カーネルといっしょにリンクするいずれのタスクも標準Cライブラリを使用し
ない場合には，カーネルを作る際に標準Cライブラリをリンクする必要はない．
この場合，システム起動時に標準Cライブラリの初期化ルーチンと終了ルーチ
ンを呼び出す必要がなくなるため，スタートアップモジュール 
（$(CPU)/startup/start.S）中の該当部分を削除する必要がある．ItIs の標
準リリースに含まれるスタートアップモジュールのソースコードは，本来は標
準Cライブラリの一部であるべきだが，ItIs の動作環境用に修正を加えている
こともあり，ItIs のリリースに含めている．

カーネルといっしょにリンクするタスクが標準Cライブラリを使う場合，カー
ネルとタスクのヒープ領域管理の衝突に注意する必要がある．具体的には，タ
スクが直接/間接的に sbrk関数を呼び出す場合には，カーネルで使用する 
sbrk関数（ターゲット依存のスタートアップモジュールに含まれている）が呼
び出されることになる．そのため，カーネルが使用するヒープ領域に加えて，
タスクが使用する領域も計算に入れてメモリ配置を決定する必要がある．また
一般には，カーネルといっしょにリンクするタスクから brk関数を呼び出すこ
とはできない．


6.6. メモリマップと配置

ItIs 動作時には，以下のメモリエリアが必要になる．

(a) カーネルコード領域

カーネルのプログラムおよび定数データが置かれる領域．ROM上に置くことも
可能．先頭アドレスを，カーネルをリンクする際の -Ttext オプションで指定
する．

(b) タスク独立部用スタック領域

タスク独立部が使用するスタックの領域．スタック領域の末尾は，タスク独立
部用スタックの初期値によって決まる．タスク独立部用スタックは通常，ター
ゲットシステム依存の初期化処理（$(CPU)/$(SYS)/sys_support.S に含まれる）
中で初期化される．

(c) カーネルデータ領域

カーネルの使用するデータ領域．固定的なデータ領域と，sbrk関数によって取
られるヒープ領域からなる．先頭アドレスを，カーネルをリンクする際の 
-Tdata オプションで指定する．

システム用メモリプール（mplid = (-4) のメモリプール）は，この領域から 
sbrk関数を使って取られる．システム用メモリプールのサイズを変更したい場
合は，システム構成設定ファイル中の sys_mpl_size で指定する．

(d) ユーザプログラム領域

ItIs カーネルは，ユーザプログラム領域の管理を行わないため，ユーザプロ
グラムはカーネルが使用しない任意のアドレスに置くことができる．

この他に，ターゲットによっては，ItIs が動作中に用いる例外ベクタテーブ
ルの領域を用意する必要がある．また，ROMモニタのワークエリアと ItIs の
使用する領域が衝突しないよう注意が必要である．


6.7. データセクションの初期化（ROM化対応）

C言語で記述したプログラムを ROM化するためには，初期化されるべきデータ
領域（データセクション）をどのように初期化するかが問題になる．また，ター
ゲットシステムの RAM上に転送したプログラムを，複数回動作させる場合にも，
データセクションをどのように再初期化するかが問題になる．

ItIs では，データセクションの初期化を行うために，extidata ユーティリティ
を用意している．extidata は，オブジェクトファイルからデータセクション
の内容を取り出し，そのデータをテキストセクションに置くものとして，アセ
ンブラのソースを生成する．extidata で生成したソースをアセンブルし，プ
ログラムと一緒にリンクすることにより，データセクションの初期値をテキス
トセクション内に含んだプログラムを生成することができる．データセクショ
ンの実際の初期化は，スタートアップモジュール内で行う．

extidata に関する詳しい説明は，extidata の先頭のコメントを参照されたい．


6.8. 他のターゲットシステムへの移植

68040 ないしは TRON仕様チップを用いた他のターゲットシステムに移植する
ために必要な作業は，基本的には，ターゲットシステムの違いを吸収するため
のモジュール（具体的には，$(CPU)/$(SYS)/sys_conf.h，sys_util.c， 
sys_support.S，sys_timer.h，sys_serial.h の 5つのファイルおよびそれら
からインクルードされるファイル）を作成することである．

その他，Makefile 等の変更も必要になる．詳しいことについては，別途相談
されたい．


6.9. 他の CPU への移植について

ItIs を他の CPU に移植するために必要な作業は，基本的には，ターゲット
CPU の違いを吸収するためのモジュール（具体的には，$(CPU) ディレクトリ
の下すべてと include/$(CPU)/itis_scint.h）を作成することである．その他，
一部のヘッダファイルに，CPU の種類を判別する #ifdef が含まれている．

ただし，移植先の CPU のアーキテクチャが 68040 や TRON仕様チップと大き
く異なる場合には，カーネル本体の改造が必要になると思われる．詳しいこと
については，別途相談されたい．


７．その他

7.1. 配布・著作権

ItIs はフリーソフトウェアであり，配布自由である．著作権については，東
京大学 坂村研究室ならびに豊橋技術科学大学 組み込みリアルタイムシステム
研究室が保有しているので，パブリックドメインソフトウェアではない．具体
的な配布条件は，各ファイルの先頭についている条件に従うものとする（この
ドキュメントの先頭にもついている）．

ItIs の配付キットの最新版は，以下の URL から WWW で取得することができ
る．

	http://www.ertl.ics.tut.ac.jp/ItIs/


7.2. 保証・サポート

ItIs はフリーソフトウェアであり，いかなる保証もできない．また，サポー
トの約束もできない．質問がある場合は，ItIs のユーザのためのメイリング
リスト（詳しくは「メイリングリスト」の項を参照）を利用されたい．

ItIs は研究・教育に利用することを目的として開発されているため，実装に
あたっては，実行性能よりも可読性や保守性を重視している．そのため，メー
カ製の同等のソフトウェアと比べて，性能的には劣るかもしれない．特に，割
込み禁止区間を短縮する努力をしていないため，最大割込み禁止時間はかなり
長くなっている．メッセージバッファ機能やランデブ機能でメッセージのコピー
を割込み禁止区間で行っているため，メッセージ長が長くなると最大割込み禁
止時間も長くなる．タスク応答性についても，同様のことが言える．また，製
品化されている ITRON仕様OS と比べると，テストは全く不十分である．


7.3. バグレポート

バグや問題点を発見した時の電子メイルによる連絡先は，以下の通り．

    itis-bug@ertl.ics.tut.ac.jp

実記憶で動作するカーネルの場合，カーネルのバグとアプリケーションのバグ
の切り分けは，一般には非常に難しい．この切り分けは，ユーザの責任である．
また，電話による問い合わせ等は受け付けない．


7.4. メイリングリスト

ItIs のユーザに対する情報提供およびユーザ相互間の情報交換を容易にする
ために，ItIsユーザのためのメイリングリストを用意している．メイリングリ
ストのアドレスは，

    itis-users@ertl.ics.tut.ac.jp

である．このメイリングリストへの登録を希望される場合は，氏名，所属，電
子メイルアドレス，電子メイル以外による連絡方法を以下に連絡されたい．

    itis-users-request@ertl.ics.tut.ac.jp


7.5. ITRON Club

仕事・勉強・趣味を問わず ITRON に興味を持つ人のための情報交換・議論の
場として，ITRON Club メイリングリストを用意している．このメイリングリ
ストには，ITRON に興味を持っている人なら誰でも参加できる．参加を希望さ
れる場合は，itron-club-request@tron.um.u-tokyo.ac.jp まで連絡されたい．

なお，このメイリングリストに送られたメイルは，後からメイリングリストに
参加された人に見せる場合がある．また，メイリングリストのメンバリストは，
メイリングリスト内で公開するので，あらかじめ了解頂きたい．


８．リファレンス

8.1. システムコール一覧

・タスク管理機能

    ER ercd = cre_tsk(ID tskid, T_CTSK *pk_ctsk);
    ER ercd = del_tsk(ID tskid);
    ER ercd = sta_tsk(ID tskid, INT stacd);
	 void ext_tsk();
	 void exd_tsk();
    ER ercd = ter_tsk(ID tskid);
    ER ercd = dis_dsp();
    ER ercd = ena_dsp();
    ER ercd = chg_pri(ID tskid, PRI tskpri);
    ER ercd = rot_rdq(PRI tskpri);
    ER ercd = rel_wai(ID tskid);
    ER ercd = get_tid(ID *p_tskid);
    ER ercd = ref_tsk(T_RTSK *pk_rtsk, ID tskid);

・タスク付属同期機能

    ER ercd = sus_tsk(ID tskid);
    ER ercd = rsm_tsk(ID tskid);
    ER ercd =frsm_tsk(ID tskid);
    ER ercd = slp_tsk();
    ER ercd =tslp_tsk(TMO tmout);
    ER ercd = wup_tsk(ID tskid);
    ER ercd = can_wup(INT *p_wupcnt, ID tskid);

・同期・通信機能

    ER ercd = cre_sem(ID semid, T_CSEM *pk_csem);
    ER ercd = del_sem(ID semid);
    ER ercd = sig_sem(ID semid);
    ER ercd = wai_sem(ID semid);
    ER ercd = preq_sem(ID semid);
    ER ercd = twai_sem(ID semid, TMO tmout);
    ER ercd = ref_sem(T_RSEM *pk_rsem, ID semid);
    ER ercd = cre_flg(ID flgid, T_CFLG *pk_cflg);
    ER ercd = del_flg(ID flgid);
    ER ercd = set_flg(ID flgid, UINT setptn);
    ER ercd = clr_flg(ID flgid, UINT clrptn);
    ER ercd = wai_flg(UINT *p_flgptn, ID flgid, UINT waiptn, UINT wfmode);
    ER ercd = pol_flg(UINT *p_flgptn, ID flgid, UINT waiptn, UINT wfmode);
    ER ercd =twai_flg(UINT *p_flgptn, ID flgid, UINT waiptn, UINT wfmode,
		      TMO tmout);
    ER ercd = ref_flg(T_RFLG *pk_rflg, ID flgid);
    ER ercd = cre_mbx(ID mbxid, T_CMBX *pk_cmbx);
    ER ercd = del_mbx(ID mbxid);
    ER ercd = snd_msg(ID mbxid, T_MSG *pk_msg);
    ER ercd = rcv_msg(T_MSG* *ppk_msg, ID mbxid);
    ER ercd =prcv_msg(T_MSG* *ppk_msg, ID mbxid);
    ER ercd =trcv_msg(T_MSG* *ppk_msg, ID mbxid, TMO tmout);
    ER ercd = ref_mbx(T_RMBX *pk_rmbx, ID mbxid);

・拡張同期・通信機能

    ER ercd = cre_mbf(ID mbfid, T_CMBF *pk_cmbf);
    ER ercd = del_mbf(ID mbfid);
    ER ercd = snd_mbf(ID mbfid, VP msg, INT msgsz);
    ER ercd =psnd_mbf(ID mbfid, VP msg, INT msgsz);
    ER ercd =tsnd_mbf(ID mbfid, VP msg, INT msgsz, TMO tmout);
    ER ercd = rcv_mbf(VP msg, INT *p_msgsz, ID mbfid);
    ER ercd =prcv_mbf(VP msg, INT *p_msgsz, ID mbfid);
    ER ercd =trcv_mbf(VP msg, INT *p_msgsz, ID mbfid, TMO tmout);
    ER ercd = ref_mbf(T_RMBF *pk_rmbf, ID mbfid);
    ER ercd = cre_por(ID porid, T_CPOR *pk_cpor);
    ER ercd = del_por(ID porid);
    ER ercd = cal_por(VP msg, INT *p_rmsgsz, ID porid, UINT calptn,
		      INT cmsgsz);
    ER ercd =pcal_por(VP msg, INT *p_rmsgsz, ID porid, UINT calptn,
		      INT cmsgsz);
    ER ercd =tcal_por(VP msg, INT *p_rmsgsz, ID porid, UINT calptn,
		      INT cmsgsz, TMO tmout);
    ER ercd = acp_por(RNO *p_rdvno, VP msg, INT *p_cmsgsz, ID porid,
		      UINT acpptn);
    ER ercd =pacp_por(RNO *p_rdvno, VP msg, INT *p_cmsgsz, ID porid,
		      UINT acpptn);
    ER ercd =tacp_por(RNO *p_rdvno, VP msg, INT *p_cmsgsz, ID porid,
		      UINT acpptn, TMO tmout);
    ER ercd = fwd_por(ID porid, UINT calptn, RNO rdvno, VP msg, INT cmsgsz);
    ER ercd = rpl_rdv(RNO rdvno, VP msg, INT rmsgsz);
    ER ercd = ref_por(T_RPOR *pk_rpor, ID porid);

・割込み管理機能

    ER ercd = def_int(UINT dintno, T_DINT *pk_dint);
    ER ercd = loc_cpu();
    ER ercd = unl_cpu();
    ER ercd = chg_iXX(UINT iXXXX);
    ER ercd = ref_iXX(UINT *p_iXXXX);

※ iXX, iXXXX の部分の名称は，ターゲットCPU 毎に定める．

・メモリプール管理機能

    ER ercd = cre_mpl(ID mplid, T_CMPL *pk_cmpl);
    ER ercd = del_mpl(ID mplid);
    ER ercd = get_blk(VP *p_blk, ID mplid, INT blksz);
    ER ercd =pget_blk(VP *p_blk, ID mplid, INT blksz);
    ER ercd =tget_blk(VP *p_blk, ID mplid, INT blksz, TMO tmout);
    ER ercd = rel_blk(ID mplid, VP blk);
    ER ercd = ref_mpl(T_RMPL *pk_rmpl, ID mplid);
    ER ercd = cre_mpf(ID mpfid, T_CMPF *pk_cmpf);
    ER ercd = del_mpf(ID mpfid);
    ER ercd = get_blf(VP *p_blf, ID mpfid);
    ER ercd =pget_blf(VP *p_blf, ID mpfid);
    ER ercd =tget_blf(VP *p_blf, ID mpfid, TMO tmout);
    ER ercd = rel_blf(ID mpfid, VP blf);
    ER ercd = ref_mpf(T_RMPF *pk_rmpf, ID mpfid);

・時間管理機能

    ER ercd = set_tim(SYSTIME *pk_tim);
    ER ercd = get_tim(SYSTIME *pk_tim);
    ER ercd = dly_tsk(DLYTIME dlytim);
    ER ercd = def_cyc(HNO cycno, T_DCYC *pk_dcyc);
    ER ercd = act_cyc(HNO cycno, UINT cycact);
    ER ercd = ref_cyc(T_RCYC *pk_rcyc, HNO cycno);
    ER ercd = def_alm(HNO almno, T_DALM *pk_dalm);
    ER ercd = ref_alm(T_RALM *pk_ralm, HNO almno);

・システム管理機能

    ER ercd = get_ver(T_VER *pk_ver);
    ER ercd = ref_sys(T_RSYS *pk_rsys);
    ER ercd = ref_cfg(T_RCFG *pk_rcfg);
    ER ercd = def_svc(FN s_fncd, T_DSVC *pk_dsvc);

・ID自動割当機能

    ER ercd =vcre_tsk(T_CTSK *pk_ctsk);
    ER ercd =vcre_sem(T_CSEM *pk_csem);
    ER ercd =vcre_flg(T_CFLG *pk_cflg);
    ER ercd =vcre_mbx(T_CMBX *pk_cmbx);
    ER ercd =vcre_mbf(T_CMBF *pk_cmbf);
    ER ercd =vcre_por(T_CPOR *pk_cpor);
    ER ercd =vcre_mpl(T_CMPL *pk_cmpl);
    ER ercd =vcre_mpf(T_CMPF *pk_cmpf);
    ER ercd =vdef_cyc(T_DCYC *pk_dcyc);
    ER ercd =vdef_alm(T_DALM *pk_dalm);

・デバッグサポート機能

    ER ercd =vset_reg(ID tskid, T_REGS *pk_regs, T_EIT *pk_eit,
		      T_CREGS *pk_cregs);
    ER ercd =vget_reg(T_REGS *pk_regs, T_EIT *pk_eit, T_CREGS *pk_cregs,
		      ID tskid);

・性能評価用システム時刻参照機能

    ER ercd =vget_tim(SYSUTIME *pk_utim);

・優先度継承セマフォ機能

    ER ercd =vcre_pis(ID pisid, T_CPIS *pk_cpis);
    ER ercd =vvcre_pis(T_CPIS *pk_cpis);
    ER ercd =vdel_pis(ID pisid);
    ER ercd =vsig_pis(ID pisid);
    ER ercd =vwai_pis(ID pisid);
    ER ercd =vpreq_pis(ID pisid);
    ER ercd =vtwai_pis(ID pisid, TMO tmout);
    ER ercd =vref_pis(T_RPIS *pk_rpis, ID pisid);

・タスク付属メイルボックス機能

    ER ercd =vsnd_tmb(ID tskid, T_MSG *pk_msg);
    ER ercd =vrcv_tmb(T_MSG **ppk_msg);
    ER ercd =vprcv_tmb(T_MSG **ppk_msg);
    ER ercd =vtrcv_tmb(T_MSG **ppk_msg, TMO tmout);
    ER ercd =vref_tmb(T_RTMB *pk_rtmb, ID tskid);


8.2. エラーコード一覧（ItIs カーネルが返すもののみ）

    E_OK	0		正常終了
    E_NOMEM	-10		メモリ不足
    E_NOSPT	-17		未サポート機能
    E_RSFN	-20		予約機能番号
    E_RSATR	-24		予約属性
    E_PAR	-33		パラメターエラー
    E_ID	-35		不正ID番号
    E_NOEXS	-52		オブジェクトが存在していない
    E_OBJ	-63		オブジェクトの状態が不正
    E_OACV	-66		オブジェクトアクセス権違反
    E_CTX	-69		コンテキストエラー
    E_QOVR	-73		キューイングのオーバーフロー
    E_DLT	-81		待ちオブジェクトが削除された
    E_TMOUT	-85		ポーリング失敗/タイムアウト
    E_RLWAI	-86		待ち状態強制解除
    EV_FULL	-225		オブジェクトテーブルフル


8.3. バージョン履歴

    1993年10月20日	Release1.1		最初のリリース版
    1993年11月8日	Release1.1 (PL=1)
    1993年12月10日	Release1.2		拡張機能のサポートを追加
    1993年12月24日	Release1.2 (PL=1)
    1994年1月17日	Release1.2 (PL=2)	β版とする
    1994年1月19日	Release1.2 (PL=3)
    1994年2月10日	Release1.2 (PL=4)
    1994年6月21日	Release1.2 (PL=5)
    1995年2月14日	Release1.3		CPU依存部を分離など大きく変更
    1995年3月15日	Release1.3 (PL=1)
    1995年6月19日	Release1.3 (PL=2)	ftp による一般公開を開始
    1996年2月17日	Release1.3 (PL=3)	（内部リリース）
    1998年1月30日	Release1.3 (PL=4)	Phase 3 最後の取りまとめ
    1998年7月6日	Release1.4		Phase 4 の最初のリリース
